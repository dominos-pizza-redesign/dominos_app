(self["webpackChunk"] = self["webpackChunk"] || []).push([["node_modules_gltf-transform_functions_dist_functions_modern_js"],{

/***/ "./node_modules/@gltf-transform/core/dist/core.modern.js":
/*!***************************************************************!*\
  !*** ./node_modules/@gltf-transform/core/dist/core.modern.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Graph": () => (/* reexport safe */ property_graph__WEBPACK_IMPORTED_MODULE_0__.Graph),
/* harmony export */   "GraphEdge": () => (/* reexport safe */ property_graph__WEBPACK_IMPORTED_MODULE_0__.GraphEdge),
/* harmony export */   "Accessor": () => (/* binding */ W),
/* harmony export */   "Animation": () => (/* binding */ H),
/* harmony export */   "AnimationChannel": () => (/* binding */ Y),
/* harmony export */   "AnimationSampler": () => (/* binding */ Z),
/* harmony export */   "Buffer": () => (/* binding */ K),
/* harmony export */   "BufferUtils": () => (/* binding */ A),
/* harmony export */   "COPY_IDENTITY": () => (/* binding */ $),
/* harmony export */   "Camera": () => (/* binding */ Q),
/* harmony export */   "ColorUtils": () => (/* binding */ E),
/* harmony export */   "DenoIO": () => (/* binding */ Rt),
/* harmony export */   "Document": () => (/* binding */ pt),
/* harmony export */   "ExtensibleProperty": () => (/* binding */ q),
/* harmony export */   "Extension": () => (/* binding */ mt),
/* harmony export */   "ExtensionProperty": () => (/* binding */ X),
/* harmony export */   "FileUtils": () => (/* binding */ S),
/* harmony export */   "Format": () => (/* binding */ T),
/* harmony export */   "GLB_BUFFER": () => (/* binding */ g),
/* harmony export */   "ImageUtils": () => (/* binding */ I),
/* harmony export */   "Logger": () => (/* binding */ C),
/* harmony export */   "Material": () => (/* binding */ it),
/* harmony export */   "MathUtils": () => (/* binding */ F),
/* harmony export */   "Mesh": () => (/* binding */ ot),
/* harmony export */   "Node": () => (/* binding */ at),
/* harmony export */   "NodeIO": () => (/* binding */ It),
/* harmony export */   "PlatformIO": () => (/* binding */ Mt),
/* harmony export */   "Primitive": () => (/* binding */ ut),
/* harmony export */   "PrimitiveTarget": () => (/* binding */ ct),
/* harmony export */   "Property": () => (/* binding */ V),
/* harmony export */   "PropertyType": () => (/* binding */ p),
/* harmony export */   "ReaderContext": () => (/* binding */ wt),
/* harmony export */   "Root": () => (/* binding */ gt),
/* harmony export */   "Scene": () => (/* binding */ lt),
/* harmony export */   "Skin": () => (/* binding */ ft),
/* harmony export */   "Texture": () => (/* binding */ dt),
/* harmony export */   "TextureChannel": () => (/* binding */ y),
/* harmony export */   "TextureInfo": () => (/* binding */ tt),
/* harmony export */   "VERSION": () => (/* binding */ d),
/* harmony export */   "VertexLayout": () => (/* binding */ m),
/* harmony export */   "WebIO": () => (/* binding */ Nt),
/* harmony export */   "WriterContext": () => (/* binding */ bt),
/* harmony export */   "bounds": () => (/* binding */ v),
/* harmony export */   "uuid": () => (/* binding */ G)
/* harmony export */ });
/* harmony import */ var property_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! property-graph */ "./node_modules/property-graph/dist/property-graph.modern.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix/vec3 */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gl-matrix/mat4 */ "./node_modules/gl-matrix/esm/mat4.js");
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
const d="v2.0.5",g="@glb.bin";var p,m,w,y,T;function v(t){const e={min:[Infinity,Infinity,Infinity],max:[-Infinity,-Infinity,-Infinity]},r=t.propertyType===p.NODE?[t]:t.listChildren();for(const t of r)t.traverse(t=>{const r=t.getMesh();if(!r)return;const s=x(r,t.getWorldMatrix());b(s.min,e),b(s.max,e)});return e}function x(t,e){const r={min:[Infinity,Infinity,Infinity],max:[-Infinity,-Infinity,-Infinity]};for(const s of t.listPrimitives()){const t=s.getAttribute("POSITION");if(!t)continue;let n=[0,0,0],i=[0,0,0];for(let s=0;s<t.getCount();s++)n=t.getElement(s,n),i=(0,gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_1__.transformMat4)(i,n,e),b(i,r)}return r}function b(t,e){for(let r=0;r<3;r++)e.min[r]=Math.min(t[r],e.min[r]),e.max[r]=Math.max(t[r],e.max[r])}!function(t){t.ACCESSOR="Accessor",t.ANIMATION="Animation",t.ANIMATION_CHANNEL="AnimationChannel",t.ANIMATION_SAMPLER="AnimationSampler",t.BUFFER="Buffer",t.CAMERA="Camera",t.MATERIAL="Material",t.MESH="Mesh",t.PRIMITIVE="Primitive",t.PRIMITIVE_TARGET="PrimitiveTarget",t.NODE="Node",t.ROOT="Root",t.SCENE="Scene",t.SKIN="Skin",t.TEXTURE="Texture",t.TEXTURE_INFO="TextureInfo"}(p||(p={})),function(t){t.INTERLEAVED="interleaved",t.SEPARATE="separate"}(m||(m={})),function(t){t.ARRAY_BUFFER="ARRAY_BUFFER",t.ELEMENT_ARRAY_BUFFER="ELEMENT_ARRAY_BUFFER",t.INVERSE_BIND_MATRICES="INVERSE_BIND_MATRICES",t.OTHER="OTHER"}(w||(w={})),function(t){t[t.R=4096]="R",t[t.G=256]="G",t[t.B=16]="B",t[t.A=1]="A"}(y||(y={})),function(t){t.GLTF="GLTF",t.GLB="GLB"}(T||(T={}));class A{static createBufferFromDataURI(t){if("undefined"==typeof Buffer){const e=atob(t.split(",")[1]),r=new Uint8Array(e.length);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return r}{const e=t.split(",")[1],r=t.indexOf("base64")>=0;return Buffer.from(e,r?"base64":"utf8")}}static encodeText(t){return"undefined"!=typeof TextEncoder?(new TextEncoder).encode(t):Buffer.from(t)}static decodeText(t){return"undefined"!=typeof TextDecoder?(new TextDecoder).decode(t):Buffer.from(t).toString("utf8")}static concat(t){let e=0;for(const r of t)e+=r.byteLength;const r=new Uint8Array(e);let s=0;for(const e of t)r.set(e,s),s+=e.byteLength;return r}static pad(t,e=0){const r=this.padNumber(t.byteLength);if(r===t.byteLength)return t;const s=new Uint8Array(r);if(s.set(t),0!==e)for(let n=t.byteLength;n<r;n++)s[n]=e;return s}static padNumber(t){return 4*Math.ceil(t/4)}static equals(t,e){if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;let r=t.byteLength;for(;r--;)if(t[r]!==e[r])return!1;return!0}static toView(t,e=0,r=Infinity){return new Uint8Array(t.buffer,t.byteOffset+e,Math.min(t.byteLength,r))}static assertView(t){if(t&&!ArrayBuffer.isView(t))throw new Error(`Method requires Uint8Array parameter; received "${typeof t}".`);return t}}class E{static hexToFactor(t,e){t=Math.floor(t);const r=e;return r[0]=(t>>16&255)/255,r[1]=(t>>8&255)/255,r[2]=(255&t)/255,this.convertSRGBToLinear(e,e)}static factorToHex(t){const e=[...t],[r,s,n]=this.convertLinearToSRGB(t,e);return 255*r<<16^255*s<<8^255*n<<0}static convertSRGBToLinear(t,e){const r=t,s=e;for(let t=0;t<3;t++)s[t]=r[t]<.04045?.0773993808*r[t]:Math.pow(.9478672986*r[t]+.0521327014,2.4);return e}static convertLinearToSRGB(t,e){const r=t,s=e;for(let t=0;t<3;t++)s[t]=r[t]<.0031308?12.92*r[t]:1.055*Math.pow(r[t],.41666)-.055;return e}}class S{static basename(t){const e=(t=new URL(t,"https://null.example").pathname).split(/[\\/]/).pop();return e.substring(0,e.lastIndexOf("."))}static extension(t){return 0!==t.indexOf("data:")?(t=new URL(t,"https://null.example").pathname).split(/[\\/]/).pop().split(/[.]/).pop():0===t.indexOf("data:image/png")?"png":0===t.indexOf("data:image/jpeg")?"jpeg":"bin"}}class M{match(t){return t.length>=8&&137===t[0]&&80===t[1]&&78===t[2]&&71===t[3]&&13===t[4]&&10===t[5]&&26===t[6]&&10===t[7]}getSize(t){const e=new DataView(t.buffer,t.byteOffset);return A.decodeText(t.slice(12,16))===M.PNG_FRIED_CHUNK_NAME?[e.getUint32(32,!1),e.getUint32(36,!1)]:[e.getUint32(16,!1),e.getUint32(20,!1)]}getChannels(t){return 4}}M.PNG_FRIED_CHUNK_NAME="CgBI";class I{static registerFormat(t,e){this.impls[t]=e}static getMimeType(t){for(const e in this.impls)if(this.impls[e].match(t))return e;return null}static getSize(t,e){return this.impls[e]?this.impls[e].getSize(t):null}static getChannels(t,e){return this.impls[e]?this.impls[e].getChannels(t):null}static getMemSize(t,e){if(!this.impls[e])return null;if(this.impls[e].getGPUByteLength)return this.impls[e].getGPUByteLength(t);let r=0;const s=this.getSize(t,e);if(!s)return null;for(;s[0]>1||s[1]>1;)r+=s[0]*s[1]*4,s[0]=Math.max(Math.floor(s[0]/2),1),s[1]=Math.max(Math.floor(s[1]/2),1);return r+=4,r}static mimeTypeToExtension(t){return"image/jpeg"===t?"jpg":t.split("/").pop()}static extensionToMimeType(t){return"jpg"===t?"image/jpeg":`image/${t}`}}function R(t,e){if(e>t.byteLength)throw new TypeError("Corrupt JPG, exceeded buffer limits");if(255!==t.getUint8(e))throw new TypeError("Invalid JPG, marker table corrupted");return t}function N(t){return"[object Object]"===Object.prototype.toString.call(t)}function O(t){if(!1===N(t))return!1;const e=t.constructor;if(void 0===e)return!0;const r=e.prototype;return!1!==N(r)&&!1!==Object.prototype.hasOwnProperty.call(r,"isPrototypeOf")}I.impls={"image/jpeg":new class{match(t){return t.length>=3&&255===t[0]&&216===t[1]&&255===t[2]}getSize(t){let e,r,s=new DataView(t.buffer,t.byteOffset+4);for(;s.byteLength;){if(e=s.getUint16(0,!1),R(s,e),r=s.getUint8(e+1),192===r||193===r||194===r)return[s.getUint16(e+7,!1),s.getUint16(e+5,!1)];s=new DataView(t.buffer,s.byteOffset+e+2)}throw new TypeError("Invalid JPG, no size found")}getChannels(t){return 3}},"image/png":new M};class C{constructor(t){this.verbosity=void 0,this.verbosity=t}debug(t){this.verbosity<=C.Verbosity.DEBUG&&console.debug(t)}info(t){this.verbosity<=C.Verbosity.INFO&&console.info(t)}warn(t){this.verbosity<=C.Verbosity.WARN&&console.warn(t)}error(t){this.verbosity<=C.Verbosity.ERROR&&console.error(t)}}C.Verbosity={SILENT:4,ERROR:3,WARN:2,INFO:1,DEBUG:0},C.DEFAULT_INSTANCE=new C(C.Verbosity.INFO);class F{static identity(t){return t}static eq(t,e){if(t.length!==e.length)return!1;for(let r=0;r<t.length;r++)if(Math.abs(t[r]-e[r])>1e-5)return!1;return!0}static denormalize(t,e){switch(e){case 5126:return t;case 5123:return t/65535;case 5121:return t/255;case 5122:return Math.max(t/32767,-1);case 5120:return Math.max(t/127,-1);default:throw new Error("Invalid component type.")}}static normalize(t,e){switch(e){case 5126:return t;case 5123:return Math.round(65535*t);case 5121:return Math.round(255*t);case 5122:return Math.round(32767*t);case 5120:return Math.round(127*t);default:throw new Error("Invalid component type.")}}static decompose(t,e,r,s){let n=(0,gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_1__.length)([t[0],t[1],t[2]]);const i=(0,gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_1__.length)([t[4],t[5],t[6]]),o=(0,gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_1__.length)([t[8],t[9],t[10]]);(0,gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_2__.determinant)(t)<0&&(n=-n),e[0]=t[12],e[1]=t[13],e[2]=t[14];const a=t.slice(),u=1/n,f=1/i,d=1/o;a[0]*=u,a[1]*=u,a[2]*=u,a[4]*=f,a[5]*=f,a[6]*=f,a[8]*=d,a[9]*=d,a[10]*=d,(0,gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_2__.getRotation)(r,a),s[0]=n,s[1]=i,s[2]=o}static compose(t,e,r,s){const n=s,i=e[0],o=e[1],a=e[2],u=e[3],c=i+i,h=o+o,l=a+a,f=i*c,d=i*h,g=i*l,p=o*h,m=o*l,w=a*l,y=u*c,T=u*h,v=u*l,x=r[0],b=r[1],A=r[2];return n[0]=(1-(p+w))*x,n[1]=(d+v)*x,n[2]=(g-T)*x,n[3]=0,n[4]=(d-v)*b,n[5]=(1-(f+w))*b,n[6]=(m+y)*b,n[7]=0,n[8]=(g+T)*A,n[9]=(m-y)*A,n[10]=(1-(f+p))*A,n[11]=0,n[12]=t[0],n[13]=t[1],n[14]=t[2],n[15]=1,n}}function B(t,e){if(!!t!=!!e)return!1;const r=t.getChild(),s=e.getChild();return r===s||r.equals(s)}function U(t,e){if(!!t!=!!e)return!1;if(t.length!==e.length)return!1;for(let r=0;r<t.length;r++){const s=t[r],n=e[r];if(s.getChild()!==n.getChild()&&!s.getChild().equals(n.getChild()))return!1}return!0}function P(t,e){if(!!t!=!!e)return!1;const r=Object.keys(t),s=Object.keys(e);if(r.length!==s.length)return!1;for(const r in t){const s=t[r],n=e[r];if(!!s!=!!n)return!1;const i=s.getChild(),o=n.getChild();if(i!==o&&!i.equals(o))return!1}return!0}function j(t,e){if(t===e)return!0;if(!!t!=!!e||!t||!e)return!1;if(t.length!==e.length)return!1;for(let r=0;r<t.length;r++)if(t[r]!==e[r])return!1;return!0}function L(t,e){if(t===e)return!0;if(!!t!=!!e)return!1;if(!O(t)||!O(e))return t===e;const r=t,s=e;let n,i=0,o=0;for(n in r)i++;for(n in s)o++;if(i!==o)return!1;for(n in r){const t=r[n],e=s[n];if(_(t)&&_(e)){if(!j(t,e))return!1}else if(O(t)&&O(e)){if(!L(t,e))return!1}else if(t!==e)return!1}return!0}function _(t){return Array.isArray(t)||ArrayBuffer.isView(t)}const D="23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ",k=new Set,z=function(){let t="";for(let e=0;e<6;e++)t+=D.charAt(Math.floor(Math.random()*D.length));return t},G=function(){for(let t=0;t<999;t++){const t=z();if(!k.has(t))return k.add(t),t}return""};class J{static dirname(t){const e=t.lastIndexOf("/");return-1===e?"./":t.substring(0,e+1)}static resolve(t,e){if(!this.isRelativePath(e))return e;const r=t.split("/"),s=e.split("/");r.pop();for(let t=0;t<s.length;t++)"."!==s[t]&&(".."===s[t]?r.pop():r.push(s[t]));return r.join("/")}static isAbsoluteURL(t){return this.PROTOCOL_REGEXP.test(t)}static isRelativePath(t){return!/^(?:[a-zA-Z]+:)?\//.test(t)}}J.DEFAULT_INIT={},J.PROTOCOL_REGEXP=/^[a-zA-Z]+:\/\//;const $=t=>t;class V extends property_graph__WEBPACK_IMPORTED_MODULE_0__.GraphNode{constructor(t,r=""){super(t),this[property_graph__WEBPACK_IMPORTED_MODULE_0__.$attributes].name=r,this.init(),this.dispatchEvent({type:"create"})}getDefaults(){return Object.assign(super.getDefaults(),{name:"",extras:{}})}getName(){return this.get("name")}setName(t){return this.set("name",t)}getExtras(){return this.get("extras")}setExtras(t){return this.set("extras",t)}clone(){return new(0,this.constructor)(this.graph).copy(this,$)}copy(t,n=$){for(const t in this[property_graph__WEBPACK_IMPORTED_MODULE_0__.$attributes]){const n=this[property_graph__WEBPACK_IMPORTED_MODULE_0__.$attributes][t];if(n instanceof property_graph__WEBPACK_IMPORTED_MODULE_0__.GraphEdge)this[property_graph__WEBPACK_IMPORTED_MODULE_0__.$immutableKeys].has(t)||n.dispose();else if(Array.isArray(n)&&n[0]instanceof property_graph__WEBPACK_IMPORTED_MODULE_0__.GraphEdge)for(const t of n)t.dispose();else if(O(n)&&Object.values(n)[0]instanceof property_graph__WEBPACK_IMPORTED_MODULE_0__.GraphEdge)for(const t in n)n[t].dispose()}for(const i in t[property_graph__WEBPACK_IMPORTED_MODULE_0__.$attributes]){const o=this[property_graph__WEBPACK_IMPORTED_MODULE_0__.$attributes][i],a=t[property_graph__WEBPACK_IMPORTED_MODULE_0__.$attributes][i];if(a instanceof property_graph__WEBPACK_IMPORTED_MODULE_0__.GraphEdge)this[property_graph__WEBPACK_IMPORTED_MODULE_0__.$immutableKeys].has(i)?o.getChild().copy(n(a.getChild()),n):this.setRef(i,n(a.getChild()),a.getAttributes());else if(Array.isArray(a)&&a[0]instanceof property_graph__WEBPACK_IMPORTED_MODULE_0__.GraphEdge)for(const t of a)this.addRef(i,n(t.getChild()),t.getAttributes());else if(O(a)&&Object.values(a)[0]instanceof property_graph__WEBPACK_IMPORTED_MODULE_0__.GraphEdge)for(const t in a){const e=a[t];this.setRefMap(i,t,n(e.getChild()),e.getAttributes())}else this[property_graph__WEBPACK_IMPORTED_MODULE_0__.$attributes][i]=O(a)?JSON.parse(JSON.stringify(a)):Array.isArray(a)||a instanceof ArrayBuffer||ArrayBuffer.isView(a)?a.slice():a}return this}equals(t){if(this===t)return!0;if(this.propertyType!==t.propertyType)return!1;for(const r in this[property_graph__WEBPACK_IMPORTED_MODULE_0__.$attributes]){const s=this[property_graph__WEBPACK_IMPORTED_MODULE_0__.$attributes][r],a=t[property_graph__WEBPACK_IMPORTED_MODULE_0__.$attributes][r];if((0,property_graph__WEBPACK_IMPORTED_MODULE_0__.isRef)(s)||(0,property_graph__WEBPACK_IMPORTED_MODULE_0__.isRef)(a)){if(!B(s,a))return!1}else if((0,property_graph__WEBPACK_IMPORTED_MODULE_0__.isRefList)(s)||(0,property_graph__WEBPACK_IMPORTED_MODULE_0__.isRefList)(a)){if(!U(s,a))return!1}else if((0,property_graph__WEBPACK_IMPORTED_MODULE_0__.isRefMap)(s)||(0,property_graph__WEBPACK_IMPORTED_MODULE_0__.isRefMap)(a)){if(!P(s,a))return!1}else if(O(s)||O(a)){if(!L(s,a))return!1}else if(_(s)||_(a)){if(!j(s,a))return!1}else if(s!==a)return!1}return!0}detach(){return this.graph.disconnectParents(this,t=>"Root"!==t.propertyType),this}listParents(){return this.graph.listParents(this)}}class q extends V{getDefaults(){return Object.assign(super.getDefaults(),{extensions:{}})}getExtension(t){return this.getRefMap("extensions",t)}setExtension(t,e){return e&&e.t(this),this.setRefMap("extensions",t,e)}listExtensions(){return this.listRefMapValues("extensions")}}class W extends q{constructor(...t){super(...t),this.i=F.identity,this.o=F.identity}init(){this.propertyType=p.ACCESSOR}getDefaults(){return Object.assign(super.getDefaults(),{array:null,type:W.Type.SCALAR,componentType:W.ComponentType.FLOAT,normalized:!1,buffer:null})}copy(t,e=$){return super.copy(t,e),this.i=t.i,this.o=t.o,this}static getElementSize(t){switch(t){case W.Type.SCALAR:return 1;case W.Type.VEC2:return 2;case W.Type.VEC3:return 3;case W.Type.VEC4:case W.Type.MAT2:return 4;case W.Type.MAT3:return 9;case W.Type.MAT4:return 16;default:throw new Error("Unexpected type: "+t)}}static getComponentSize(t){switch(t){case W.ComponentType.BYTE:case W.ComponentType.UNSIGNED_BYTE:return 1;case W.ComponentType.SHORT:case W.ComponentType.UNSIGNED_SHORT:return 2;case W.ComponentType.UNSIGNED_INT:case W.ComponentType.FLOAT:return 4;default:throw new Error("Unexpected component type: "+t)}}getMinNormalized(t){const e=this.getElementSize();this.getMin(t);for(let r=0;r<e;r++)t[r]=this.o(t[r]);return t}getMin(t){const e=this.get("array"),r=this.getCount(),s=this.getElementSize();for(let e=0;e<s;e++)t[e]=Infinity;for(let n=0;n<r*s;n+=s)for(let r=0;r<s;r++){const s=e[n+r];Number.isFinite(s)&&(t[r]=Math.min(t[r],s))}return t}getMaxNormalized(t){const e=this.getElementSize();this.getMax(t);for(let r=0;r<e;r++)t[r]=this.o(t[r]);return t}getMax(t){const e=this.get("array"),r=this.getCount(),s=this.getElementSize();for(let e=0;e<s;e++)t[e]=-Infinity;for(let n=0;n<r*s;n+=s)for(let r=0;r<s;r++){const s=e[n+r];Number.isFinite(s)&&(t[r]=Math.max(t[r],s))}return t}getCount(){const t=this.get("array");return t?t.length/this.getElementSize():0}getType(){return this.get("type")}setType(t){return this.set("type",t)}getElementSize(){return W.getElementSize(this.get("type"))}getComponentSize(){return this.get("array").BYTES_PER_ELEMENT}getComponentType(){return this.get("componentType")}getNormalized(){return this.get("normalized")}setNormalized(t){return this.set("normalized",t),t?(this.o=t=>F.denormalize(t,this.get("componentType")),this.i=t=>F.normalize(t,this.get("componentType"))):(this.o=F.identity,this.i=F.identity),this}getScalar(t){const e=this.getElementSize();return this.o(this.get("array")[t*e])}setScalar(t,e){return this.get("array")[t*this.getElementSize()]=this.i(e),this}getElement(t,e){const r=this.getElementSize(),s=this.get("array");for(let n=0;n<r;n++)e[n]=this.o(s[t*r+n]);return e}setElement(t,e){const r=this.getElementSize(),s=this.get("array");for(let n=0;n<r;n++)s[t*r+n]=this.i(e[n]);return this}getBuffer(){return this.getRef("buffer")}setBuffer(t){return this.setRef("buffer",t)}getArray(){return this.get("array")}setArray(t){return this.set("componentType",t?function(t){switch(t.constructor){case Float32Array:return W.ComponentType.FLOAT;case Uint32Array:return W.ComponentType.UNSIGNED_INT;case Uint16Array:return W.ComponentType.UNSIGNED_SHORT;case Uint8Array:return W.ComponentType.UNSIGNED_BYTE;case Int16Array:return W.ComponentType.SHORT;case Int8Array:return W.ComponentType.BYTE;default:throw new Error("Unknown accessor componentType.")}}(t):W.ComponentType.FLOAT),this.set("array",t),this}getByteLength(){const t=this.get("array");return t?t.byteLength:0}}W.Type={SCALAR:"SCALAR",VEC2:"VEC2",VEC3:"VEC3",VEC4:"VEC4",MAT2:"MAT2",MAT3:"MAT3",MAT4:"MAT4"},W.ComponentType={BYTE:5120,UNSIGNED_BYTE:5121,SHORT:5122,UNSIGNED_SHORT:5123,UNSIGNED_INT:5125,FLOAT:5126};class H extends q{init(){this.propertyType=p.ANIMATION}getDefaults(){return Object.assign(super.getDefaults(),{channels:[],samplers:[]})}addChannel(t){return this.addRef("channels",t)}removeChannel(t){return this.removeRef("channels",t)}listChannels(){return this.listRefs("channels")}addSampler(t){return this.addRef("samplers",t)}removeSampler(t){return this.removeRef("samplers",t)}listSamplers(){return this.listRefs("samplers")}}class Y extends q{init(){this.propertyType=p.ANIMATION_CHANNEL}getDefaults(){return Object.assign(super.getDefaults(),{targetPath:null,targetNode:null,sampler:null})}getTargetPath(){return this.get("targetPath")}setTargetPath(t){return this.set("targetPath",t)}getTargetNode(){return this.getRef("targetNode")}setTargetNode(t){return this.setRef("targetNode",t)}getSampler(){return this.getRef("sampler")}setSampler(t){return this.setRef("sampler",t)}}Y.TargetPath={TRANSLATION:"translation",ROTATION:"rotation",SCALE:"scale",WEIGHTS:"weights"};class Z extends q{init(){this.propertyType=p.ANIMATION_SAMPLER}getDefaultAttributes(){return Object.assign(super.getDefaults(),{interpolation:Z.Interpolation.LINEAR,input:null,output:null})}getInterpolation(){return this.get("interpolation")}setInterpolation(t){return this.set("interpolation",t)}getInput(){return this.getRef("input")}setInput(t){return this.setRef("input",t,{usage:w.OTHER})}getOutput(){return this.getRef("output")}setOutput(t){return this.setRef("output",t,{usage:w.OTHER})}}Z.Interpolation={LINEAR:"LINEAR",STEP:"STEP",CUBICSPLINE:"CUBICSPLINE"};class K extends q{init(){this.propertyType=p.BUFFER}getDefaults(){return Object.assign(super.getDefaults(),{uri:""})}getURI(){return this.get("uri")}setURI(t){return this.set("uri",t)}}class Q extends q{init(){this.propertyType=p.CAMERA}getDefaults(){return Object.assign(super.getDefaults(),{type:Q.Type.PERSPECTIVE,znear:.1,zfar:100,aspectRatio:null,yfov:2*Math.PI*50/360,xmag:1,ymag:1})}getType(){return this.get("type")}setType(t){return this.set("type",t)}getZNear(){return this.get("znear")}setZNear(t){return this.set("znear",t)}getZFar(){return this.get("zfar")}setZFar(t){return this.set("zfar",t)}getAspectRatio(){return this.get("aspectRatio")}setAspectRatio(t){return this.set("aspectRatio",t)}getYFov(){return this.get("yfov")}setYFov(t){return this.set("yfov",t)}getXMag(){return this.get("xmag")}setXMag(t){return this.set("xmag",t)}getYMag(){return this.get("ymag")}setYMag(t){return this.set("ymag",t)}}Q.Type={PERSPECTIVE:"perspective",ORTHOGRAPHIC:"orthographic"};class X extends V{t(t){if(!this.parentTypes.includes(t.propertyType))throw new Error(`Parent "${t.propertyType}" invalid for child "${this.propertyType}".`)}}X.EXTENSION_NAME=void 0;class tt extends q{init(){this.propertyType=p.TEXTURE_INFO}getDefaults(){return Object.assign(super.getDefaults(),{texCoord:0,magFilter:null,minFilter:null,wrapS:tt.WrapMode.REPEAT,wrapT:tt.WrapMode.REPEAT})}getTexCoord(){return this.get("texCoord")}setTexCoord(t){return this.set("texCoord",t)}getMagFilter(){return this.get("magFilter")}setMagFilter(t){return this.set("magFilter",t)}getMinFilter(){return this.get("minFilter")}setMinFilter(t){return this.set("minFilter",t)}getWrapS(){return this.get("wrapS")}setWrapS(t){return this.set("wrapS",t)}getWrapT(){return this.get("wrapT")}setWrapT(t){return this.set("wrapT",t)}}tt.WrapMode={CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,REPEAT:10497},tt.MagFilter={NEAREST:9728,LINEAR:9729},tt.MinFilter={NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987};const{R:et,G:rt,B:st,A:nt}=y;class it extends q{init(){this.propertyType=p.MATERIAL}getDefaults(){return Object.assign(super.getDefaults(),{alphaMode:it.AlphaMode.OPAQUE,alphaCutoff:.5,doubleSided:!1,baseColorFactor:[1,1,1,1],baseColorTexture:null,baseColorTextureInfo:new tt(this.graph,"baseColorTextureInfo"),emissiveFactor:[0,0,0],emissiveTexture:null,emissiveTextureInfo:new tt(this.graph,"emissiveTextureInfo"),normalScale:1,normalTexture:null,normalTextureInfo:new tt(this.graph,"normalTextureInfo"),occlusionStrength:1,occlusionTexture:null,occlusionTextureInfo:new tt(this.graph,"occlusionTextureInfo"),roughnessFactor:1,metallicFactor:1,metallicRoughnessTexture:null,metallicRoughnessTextureInfo:new tt(this.graph,"metallicRoughnessTextureInfo")})}getDoubleSided(){return this.get("doubleSided")}setDoubleSided(t){return this.set("doubleSided",t)}getAlpha(){return this.get("baseColorFactor")[3]}setAlpha(t){const e=this.get("baseColorFactor").slice();return e[3]=t,this.set("baseColorFactor",e)}getAlphaMode(){return this.get("alphaMode")}setAlphaMode(t){return this.set("alphaMode",t)}getAlphaCutoff(){return this.get("alphaCutoff")}setAlphaCutoff(t){return this.set("alphaCutoff",t)}getBaseColorFactor(){return this.get("baseColorFactor")}setBaseColorFactor(t){return this.set("baseColorFactor",t)}getBaseColorHex(){return E.factorToHex(this.get("baseColorFactor"))}setBaseColorHex(t){const e=this.get("baseColorFactor").slice();return this.set("baseColorFactor",E.hexToFactor(t,e))}getBaseColorTexture(){return this.getRef("baseColorTexture")}getBaseColorTextureInfo(){return this.getRef("baseColorTexture")?this.getRef("baseColorTextureInfo"):null}setBaseColorTexture(t){return this.setRef("baseColorTexture",t,{channels:et|rt|st|nt})}getEmissiveFactor(){return this.get("emissiveFactor")}setEmissiveFactor(t){return this.set("emissiveFactor",t)}getEmissiveHex(){return E.factorToHex(this.get("emissiveFactor"))}setEmissiveHex(t){const e=this.get("emissiveFactor").slice();return this.set("emissiveFactor",E.hexToFactor(t,e))}getEmissiveTexture(){return this.getRef("emissiveTexture")}getEmissiveTextureInfo(){return this.getRef("emissiveTexture")?this.getRef("emissiveTextureInfo"):null}setEmissiveTexture(t){return this.setRef("emissiveTexture",t,{channels:et|rt|st})}getNormalScale(){return this.get("normalScale")}setNormalScale(t){return this.set("normalScale",t)}getNormalTexture(){return this.getRef("normalTexture")}getNormalTextureInfo(){return this.getRef("normalTexture")?this.getRef("normalTextureInfo"):null}setNormalTexture(t){return this.setRef("normalTexture",t,{channels:et|rt|st})}getOcclusionStrength(){return this.get("occlusionStrength")}setOcclusionStrength(t){return this.set("occlusionStrength",t)}getOcclusionTexture(){return this.getRef("occlusionTexture")}getOcclusionTextureInfo(){return this.getRef("occlusionTexture")?this.getRef("occlusionTextureInfo"):null}setOcclusionTexture(t){return this.setRef("occlusionTexture",t,{channels:et})}getRoughnessFactor(){return this.get("roughnessFactor")}setRoughnessFactor(t){return this.set("roughnessFactor",t)}getMetallicFactor(){return this.get("metallicFactor")}setMetallicFactor(t){return this.set("metallicFactor",t)}getMetallicRoughnessTexture(){return this.getRef("metallicRoughnessTexture")}getMetallicRoughnessTextureInfo(){return this.getRef("metallicRoughnessTexture")?this.getRef("metallicRoughnessTextureInfo"):null}setMetallicRoughnessTexture(t){return this.setRef("metallicRoughnessTexture",t,{channels:rt|st})}}it.AlphaMode={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};class ot extends q{init(){this.propertyType=p.MESH}getDefaults(){return Object.assign(super.getDefaults(),{weights:[],primitives:[]})}addPrimitive(t){return this.addRef("primitives",t)}removePrimitive(t){return this.removeRef("primitives",t)}listPrimitives(){return this.listRefs("primitives")}getWeights(){return this.get("weights")}setWeights(t){return this.set("weights",t)}}class at extends q{constructor(...t){super(...t),this.u=null}init(){this.propertyType=p.NODE}getDefaults(){return Object.assign(super.getDefaults(),{translation:[0,0,0],rotation:[0,0,0,1],scale:[1,1,1],weights:[],camera:null,mesh:null,skin:null,children:[]})}copy(t,e=$){if(e===$)throw new Error("Node cannot be copied.");return super.copy(t,e)}getTranslation(){return this.get("translation")}getRotation(){return this.get("rotation")}getScale(){return this.get("scale")}setTranslation(t){return this.set("translation",t)}setRotation(t){return this.set("rotation",t)}setScale(t){return this.set("scale",t)}getMatrix(){return F.compose(this.get("translation"),this.get("rotation"),this.get("scale"),[])}setMatrix(t){const e=this.get("translation").slice(),r=this.get("rotation").slice(),s=this.get("scale").slice();return F.decompose(t,e,r,s),this.set("translation",e).set("rotation",r).set("scale",s)}getWorldTranslation(){const t=[0,0,0];return F.decompose(this.getWorldMatrix(),t,[0,0,0,1],[1,1,1]),t}getWorldRotation(){const t=[0,0,0,1];return F.decompose(this.getWorldMatrix(),[0,0,0],t,[1,1,1]),t}getWorldScale(){const t=[1,1,1];return F.decompose(this.getWorldMatrix(),[0,0,0],[0,0,0,1],t),t}getWorldMatrix(){const t=[];for(let e=this;e instanceof at;e=e.u)t.push(e);let e;const r=t.pop().getMatrix();for(;e=t.pop();)(0,gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_2__.multiply)(r,r,e.getMatrix());return r}addChild(t){t.u&&t.u.removeChild(t),this.addRef("children",t),t.u=this;const r=this[property_graph__WEBPACK_IMPORTED_MODULE_0__.$attributes].children;return r[r.length-1].addEventListener("dispose",()=>t.u=null),this}removeChild(t){return this.removeRef("children",t)}listChildren(){return this.listRefs("children")}getParent(){return this.u}getMesh(){return this.getRef("mesh")}setMesh(t){return this.setRef("mesh",t)}getCamera(){return this.getRef("camera")}setCamera(t){return this.setRef("camera",t)}getSkin(){return this.getRef("skin")}setSkin(t){return this.setRef("skin",t)}getWeights(){return this.get("weights")}setWeights(t){return this.set("weights",t)}traverse(t){t(this);for(const e of this.listChildren())e.traverse(t);return this}}class ut extends q{init(){this.propertyType=p.PRIMITIVE}getDefaults(){return Object.assign(super.getDefaults(),{mode:ut.Mode.TRIANGLES,material:null,indices:null,attributes:{},targets:[]})}getIndices(){return this.getRef("indices")}setIndices(t){return this.setRef("indices",t,{usage:w.ELEMENT_ARRAY_BUFFER})}getAttribute(t){return this.getRefMap("attributes",t)}setAttribute(t,e){return this.setRefMap("attributes",t,e,{usage:w.ARRAY_BUFFER})}listAttributes(){return this.listRefMapValues("attributes")}listSemantics(){return this.listRefMapKeys("attributes")}getMaterial(){return this.getRef("material")}setMaterial(t){return this.setRef("material",t)}getMode(){return this.get("mode")}setMode(t){return this.set("mode",t)}listTargets(){return this.listRefs("targets")}addTarget(t){return this.addRef("targets",t)}removeTarget(t){return this.removeRef("targets",t)}}ut.Mode={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6};class ct extends V{init(){this.propertyType=p.PRIMITIVE_TARGET}getDefaults(){return Object.assign(super.getDefaults(),{attributes:{}})}getAttribute(t){return this.getRefMap("attributes",t)}setAttribute(t,e){return this.setRefMap("attributes",t,e,{usage:w.ARRAY_BUFFER})}listAttributes(){return this.listRefMapValues("attributes")}listSemantics(){return this.listRefMapKeys("attributes")}}function ht(){return(ht=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var s in r)Object.prototype.hasOwnProperty.call(r,s)&&(t[s]=r[s])}return t}).apply(this,arguments)}class lt extends q{init(){this.propertyType=p.SCENE}getDefaults(){return Object.assign(super.getDefaults(),{children:[]})}copy(t,e=$){if(e===$)throw new Error("Scene cannot be copied.");return super.copy(t,e)}addChild(t){t.u&&t.u.removeChild(t),this.addRef("children",t),t.u=this;const r=this[property_graph__WEBPACK_IMPORTED_MODULE_0__.$attributes].children;return r[r.length-1].addEventListener("dispose",()=>t.u=null),this}removeChild(t){return this.removeRef("children",t)}listChildren(){return this.listRefs("children")}traverse(t){for(const e of this.listChildren())e.traverse(t);return this}}class ft extends q{init(){this.propertyType=p.SKIN}getDefaults(){return Object.assign(super.getDefaults(),{skeleton:null,inverseBindMatrices:null,joints:[]})}getSkeleton(){return this.getRef("skeleton")}setSkeleton(t){return this.setRef("skeleton",t)}getInverseBindMatrices(){return this.getRef("inverseBindMatrices")}setInverseBindMatrices(t){return this.setRef("inverseBindMatrices",t,{usage:w.INVERSE_BIND_MATRICES})}addJoint(t){return this.addRef("joints",t)}removeJoint(t){return this.removeRef("joints",t)}listJoints(){return this.listRefs("joints")}}class dt extends q{init(){this.propertyType=p.TEXTURE}getDefaults(){return Object.assign(super.getDefaults(),{image:null,mimeType:"",uri:""})}getMimeType(){return this.get("mimeType")||I.extensionToMimeType(S.extension(this.get("uri")))}setMimeType(t){return this.set("mimeType",t)}getURI(){return this.get("uri")}setURI(t){return this.set("uri",t),this.set("mimeType",I.extensionToMimeType(S.extension(t))),this}getImage(){return this.get("image")}setImage(t){return this.set("image",A.assertView(t))}getSize(){const t=this.get("image");return t?I.getSize(t,this.getMimeType()):null}}class gt extends q{init(){this.propertyType=p.ROOT}getDefaults(){return Object.assign(super.getDefaults(),{asset:{generator:"glTF-Transform v2.0.5",version:"2.0"},defaultScene:null,accessors:[],animations:[],buffers:[],cameras:[],materials:[],meshes:[],nodes:[],scenes:[],skins:[],textures:[]})}constructor(t){super(t),this.h=new Set,t.addEventListener("node:create",t=>{this.l(t.target)})}clone(){throw new Error("Root cannot be cloned.")}copy(t,e=$){if(e===$)throw new Error("Root cannot be copied.");this.set("asset",ht({},t.get("asset"))),this.setName(t.getName()),this.setExtras(ht({},t.getExtras())),this.setDefaultScene(t.getDefaultScene()?e(t.getDefaultScene()):null);for(const r of t.listRefMapKeys("extensions")){const s=t.getExtension(r);this.setExtension(r,e(s))}return this}l(t){return t instanceof lt?this.addRef("scenes",t):t instanceof at?this.addRef("nodes",t):t instanceof Q?this.addRef("cameras",t):t instanceof ft?this.addRef("skins",t):t instanceof ot?this.addRef("meshes",t):t instanceof it?this.addRef("materials",t):t instanceof dt?this.addRef("textures",t):t instanceof H?this.addRef("animations",t):t instanceof W?this.addRef("accessors",t):t instanceof K&&this.addRef("buffers",t),this}getAsset(){return this.get("asset")}listExtensionsUsed(){return Array.from(this.h)}listExtensionsRequired(){return this.listExtensionsUsed().filter(t=>t.isRequired())}g(t){return this.h.add(t),this}p(t){return this.h.delete(t),this}listScenes(){return this.listRefs("scenes")}setDefaultScene(t){return this.setRef("defaultScene",t)}getDefaultScene(){return this.getRef("defaultScene")}listNodes(){return this.listRefs("nodes")}listCameras(){return this.listRefs("cameras")}listSkins(){return this.listRefs("skins")}listMeshes(){return this.listRefs("meshes")}listMaterials(){return this.listRefs("materials")}listTextures(){return this.listRefs("textures")}listAnimations(){return this.listRefs("animations")}listAccessors(){return this.listRefs("accessors")}listBuffers(){return this.listRefs("buffers")}}class pt{constructor(){this.m=new property_graph__WEBPACK_IMPORTED_MODULE_0__.Graph,this.T=new gt(this.m),this.v=C.DEFAULT_INSTANCE}getRoot(){return this.T}getGraph(){return this.m}getLogger(){return this.v}setLogger(t){return this.v=t,this}clone(){return(new pt).setLogger(this.v).merge(this)}merge(t){for(const e of t.getRoot().listExtensionsUsed()){const t=this.createExtension(e.constructor);e.isRequired()&&t.setRequired(!0)}const e=new Set,r=new Map;e.add(t.T),r.set(t.T,this.T);for(const s of t.m.listEdges())for(const t of[s.getParent(),s.getChild()]){if(e.has(t))continue;let s;s=t.propertyType===p.TEXTURE_INFO?t:new(0,t.constructor)(this.m),r.set(t,s),e.add(t)}const s=t=>{const e=r.get(t);if(!e)throw new Error("Could resolve property.");return e};for(const t of e){const e=r.get(t);if(!e)throw new Error("Could resolve property.");e.copy(t,s)}return this}async transform(...t){const e=t.map(t=>t.name);for(const r of t)await r(this,{stack:e});return this}createExtension(t){const e=t.EXTENSION_NAME;return this.getRoot().listExtensionsUsed().find(t=>t.extensionName===e)||new t(this)}createScene(t=""){return new lt(this.m,t)}createNode(t=""){return new at(this.m,t)}createCamera(t=""){return new Q(this.m,t)}createSkin(t=""){return new ft(this.m,t)}createMesh(t=""){return new ot(this.m,t)}createPrimitive(){return new ut(this.m)}createPrimitiveTarget(t=""){return new ct(this.m,t)}createMaterial(t=""){return new it(this.m,t)}createTexture(t=""){return new dt(this.m,t)}createAnimation(t=""){return new H(this.m,t)}createAnimationChannel(t=""){return new Y(this.m,t)}createAnimationSampler(t=""){return new Z(this.m,t)}createAccessor(t="",e=null){return e||(e=this.getRoot().listBuffers()[0]),new W(this.m,t).setBuffer(e)}createBuffer(t=""){return new K(this.m,t)}}class mt{constructor(t){this.extensionName="",this.prereadTypes=[],this.prewriteTypes=[],this.readDependencies=[],this.writeDependencies=[],this.document=void 0,this.required=!1,this.properties=new Set,this.S=void 0,this.document=t,t.getRoot().g(this),this.S=t=>{const e=t,r=e.target;r instanceof X&&r.extensionName===this.extensionName&&("node:create"===e.type&&this.M(r),"node:dispose"===e.type&&this.I(r))};const e=t.getGraph();e.addEventListener("node:create",this.S),e.addEventListener("node:dispose",this.S)}dispose(){this.document.getRoot().p(this);const t=this.document.getGraph();t.removeEventListener("node:create",this.S),t.removeEventListener("node:dispose",this.S);for(const t of this.properties)t.dispose()}static register(){}isRequired(){return this.required}setRequired(t){return this.required=t,this}M(t){return this.properties.add(t),this}I(t){return this.properties.delete(t),this}install(t,e){return this}preread(t,e){return this}prewrite(t,e){return this}}mt.EXTENSION_NAME=void 0;class wt{constructor(t){this.jsonDoc=void 0,this.buffers=[],this.bufferViews=[],this.bufferViewBuffers=[],this.accessors=[],this.textures=[],this.textureInfos=new Map,this.materials=[],this.meshes=[],this.cameras=[],this.nodes=[],this.skins=[],this.animations=[],this.scenes=[],this.jsonDoc=t}setTextureInfo(t,e){this.textureInfos.set(t,e),void 0!==e.texCoord&&t.setTexCoord(e.texCoord);const r=this.jsonDoc.json.textures[e.index];if(void 0===r.sampler)return;const s=this.jsonDoc.json.samplers[r.sampler];void 0!==s.magFilter&&t.setMagFilter(s.magFilter),void 0!==s.minFilter&&t.setMinFilter(s.minFilter),void 0!==s.wrapS&&t.setWrapS(s.wrapS),void 0!==s.wrapT&&t.setWrapT(s.wrapT)}}const yt={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Tt={logger:C.DEFAULT_INSTANCE,extensions:[],dependencies:{}};function vt(t,e){const r=e.bufferViews[t.bufferView],s=e.jsonDoc.json.bufferViews[t.bufferView],n=yt[t.componentType],i=W.getElementSize(t.type),o=n.BYTES_PER_ELEMENT;if(void 0!==s.byteStride&&s.byteStride!==i*o)return function(t,e){const r=e.bufferViews[t.bufferView],s=e.jsonDoc.json.bufferViews[t.bufferView],n=yt[t.componentType],i=W.getElementSize(t.type),o=n.BYTES_PER_ELEMENT,a=t.byteOffset||0,u=new n(t.count*i),c=new DataView(r.buffer,r.byteOffset,r.byteLength),h=s.byteStride;for(let e=0;e<t.count;e++)for(let r=0;r<i;r++){const s=a+e*h+r*o;let n;switch(t.componentType){case W.ComponentType.FLOAT:n=c.getFloat32(s,!0);break;case W.ComponentType.UNSIGNED_INT:n=c.getUint32(s,!0);break;case W.ComponentType.UNSIGNED_SHORT:n=c.getUint16(s,!0);break;case W.ComponentType.UNSIGNED_BYTE:n=c.getUint8(s);break;case W.ComponentType.SHORT:n=c.getInt16(s,!0);break;case W.ComponentType.BYTE:n=c.getInt8(s);break;default:throw new Error(`Unexpected componentType "${t.componentType}".`)}u[e*i+r]=n}return u}(t,e);const a=r.byteOffset+(t.byteOffset||0);return new n(r.buffer.slice(a,a+t.count*i*o))}var xt;!function(t){t[t.ARRAY_BUFFER=34962]="ARRAY_BUFFER",t[t.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER"}(xt||(xt={}));class bt{constructor(t,e,r){this.N=void 0,this.jsonDoc=void 0,this.options=void 0,this.accessorIndexMap=new Map,this.animationIndexMap=new Map,this.bufferIndexMap=new Map,this.cameraIndexMap=new Map,this.skinIndexMap=new Map,this.materialIndexMap=new Map,this.meshIndexMap=new Map,this.nodeIndexMap=new Map,this.imageIndexMap=new Map,this.textureDefIndexMap=new Map,this.textureInfoDefMap=new Map,this.samplerDefIndexMap=new Map,this.sceneIndexMap=new Map,this.imageBufferViews=[],this.otherBufferViews=new Map,this.otherBufferViewsIndexMap=new Map,this.extensionData={},this.bufferURIGenerator=void 0,this.imageURIGenerator=void 0,this.logger=void 0,this.O=new Map,this.accessorUsageGroupedByParent=new Set(["ARRAY_BUFFER"]),this.accessorParents=new Map,this.N=t,this.jsonDoc=e,this.options=r;const s=t.getRoot(),n=s.listBuffers().length,i=s.listTextures().length;this.bufferURIGenerator=new At(n>1,r.basename),this.imageURIGenerator=new At(i>1,r.basename),this.logger=t.getLogger()}createTextureInfoDef(t,e){const r={magFilter:e.getMagFilter()||void 0,minFilter:e.getMinFilter()||void 0,wrapS:e.getWrapS(),wrapT:e.getWrapT()},s=JSON.stringify(r);this.samplerDefIndexMap.has(s)||(this.samplerDefIndexMap.set(s,this.jsonDoc.json.samplers.length),this.jsonDoc.json.samplers.push(r));const n={source:this.imageIndexMap.get(t),sampler:this.samplerDefIndexMap.get(s)},i=JSON.stringify(n);this.textureDefIndexMap.has(i)||(this.textureDefIndexMap.set(i,this.jsonDoc.json.textures.length),this.jsonDoc.json.textures.push(n));const o={index:this.textureDefIndexMap.get(i)};return 0!==e.getTexCoord()&&(o.texCoord=e.getTexCoord()),this.textureInfoDefMap.set(e,o),o}createPropertyDef(t){const e={};return t.getName()&&(e.name=t.getName()),Object.keys(t.getExtras()).length>0&&(e.extras=t.getExtras()),e}createAccessorDef(t){const e=this.createPropertyDef(t);return e.type=t.getType(),e.componentType=t.getComponentType(),e.count=t.getCount(),this.N.getGraph().listParentEdges(t).some(t=>"attributes"===t.getName()&&"POSITION"===t.getAttributes().key||"input"===t.getName())&&(e.max=t.getMax([]).map(Math.fround),e.min=t.getMin([]).map(Math.fround)),t.getNormalized()&&(e.normalized=t.getNormalized()),e}createImageData(t,e,r){if(this.options.format===T.GLB)this.imageBufferViews.push(e),t.bufferView=this.jsonDoc.json.bufferViews.length,this.jsonDoc.json.bufferViews.push({buffer:0,byteOffset:-1,byteLength:e.byteLength});else{const s=I.mimeTypeToExtension(r.getMimeType());t.uri=this.imageURIGenerator.createURI(r,s),this.jsonDoc.resources[t.uri]=e}}getAccessorUsage(t){const e=this.O.get(t);if(e)return e;for(const e of this.N.getGraph().listParentEdges(t)){const{usage:t}=e.getAttributes();if(t)return t;e.getParent().propertyType!==p.ROOT&&this.N.getLogger().warn(`Missing attribute ".usage" on edge, "${e.getName()}".`)}return bt.BufferViewUsage.OTHER}addAccessorToUsageGroup(t,e){const r=this.O.get(t);if(r&&r!==e)throw new Error(`Accessor with usage "${r}" cannot be reused as "${e}".`);return this.O.set(t,e),this}listAccessorUsageGroups(){const t={};for(const[e,r]of Array.from(this.O.entries()))t[r]=t[r]||[],t[r].push(e);return t}}bt.BufferViewTarget=xt,bt.BufferViewUsage=w,bt.USAGE_TO_TARGET={[w.ARRAY_BUFFER]:xt.ARRAY_BUFFER,[w.ELEMENT_ARRAY_BUFFER]:xt.ELEMENT_ARRAY_BUFFER};class At{constructor(t,e){this.multiple=void 0,this.basename=void 0,this.counter=1,this.multiple=t,this.basename=e}createURI(t,e){return t.getURI()?t.getURI():this.multiple?`${this.basename}_${this.counter++}.${e}`:`${this.basename}.${e}`}}const{BufferViewUsage:Et}=bt;var St;!function(t){t[t.JSON=1313821514]="JSON",t[t.BIN=5130562]="BIN"}(St||(St={}));class Mt{constructor(){this.v=C.DEFAULT_INSTANCE,this.h=new Set,this.C={},this.F=m.INTERLEAVED,this.lastReadBytes=0,this.lastWriteBytes=0}setLogger(t){return this.v=t,this}registerExtensions(t){for(const e of t)this.h.add(e),e.register();return this}registerDependencies(t){return Object.assign(this.C,t),this}setVertexLayout(t){return this.F=t,this}async read(t){return await this.readJSON(await this.readAsJSON(t))}async readAsJSON(t){return t.match(/^data:application\/octet-stream;/)||"glb"===S.extension(t)?this.U(t):this.P(t)}async readJSON(t){return t=this.j(t),this.L(t),class{static read(t,e=Tt){const r=ht({},Tt,e),{json:s}=t,n=new pt;this.validate(t,r);const i=new wt(t),o=s.asset,a=n.getRoot().getAsset();o.copyright&&(a.copyright=o.copyright),o.extras&&(a.extras=o.extras),void 0!==s.extras&&n.getRoot().setExtras(ht({},s.extras));const u=s.extensionsUsed||[],c=s.extensionsRequired||[];for(const t of r.extensions)if(u.includes(t.EXTENSION_NAME)){const e=n.createExtension(t).setRequired(c.includes(t.EXTENSION_NAME));for(const t of e.readDependencies)e.install(t,r.dependencies[t])}const h=s.buffers||[];n.getRoot().listExtensionsUsed().filter(t=>t.prereadTypes.includes(p.BUFFER)).forEach(t=>t.preread(i,p.BUFFER)),i.buffers=h.map(t=>{const e=n.createBuffer(t.name);return t.extras&&e.setExtras(t.extras),t.uri&&0!==t.uri.indexOf("__")&&e.setURI(t.uri),e}),i.bufferViewBuffers=(s.bufferViews||[]).map((e,r)=>{if(!i.bufferViews[r]){const s=t.json.buffers[e.buffer];i.bufferViews[r]=A.toView(s.uri?t.resources[s.uri]:t.resources["@glb.bin"],e.byteOffset||0,e.byteLength)}return i.buffers[e.buffer]}),i.accessors=(s.accessors||[]).map(t=>{const e=n.createAccessor(t.name,i.bufferViewBuffers[t.bufferView]).setType(t.type);if(t.extras&&e.setExtras(t.extras),void 0!==t.normalized&&e.setNormalized(t.normalized),void 0===t.bufferView&&!t.sparse)return e;let r;return r=void 0!==t.sparse?function(t,e){const r=yt[t.componentType],s=W.getElementSize(t.type);let n;n=void 0!==t.bufferView?vt(t,e):new r(t.count*s);const i=t.sparse,o=i.count,a=ht({},t,i.indices,{count:o,type:"SCALAR"}),u=ht({},t,i.values,{count:o}),c=vt(a,e),h=vt(u,e);for(let t=0;t<a.count;t++)for(let e=0;e<s;e++)n[c[t]*s+e]=h[t*s+e];return n}(t,i):vt(t,i),e.setArray(r),e});const l=s.images||[],f=s.textures||[];n.getRoot().listExtensionsUsed().filter(t=>t.prereadTypes.includes(p.TEXTURE)).forEach(t=>t.preread(i,p.TEXTURE)),i.textures=l.map(e=>{const r=n.createTexture(e.name);if(e.extras&&r.setExtras(e.extras),void 0!==e.bufferView){const n=s.bufferViews[e.bufferView],i=t.json.buffers[n.buffer],o=n.byteOffset||0,a=(i.uri?t.resources[i.uri]:t.resources["@glb.bin"]).slice(o,o+n.byteLength);r.setImage(a)}else void 0!==e.uri&&(r.setImage(t.resources[e.uri]),0!==e.uri.indexOf("__")&&r.setURI(e.uri));if(void 0!==e.mimeType)r.setMimeType(e.mimeType);else if(e.uri){const t=S.extension(e.uri);r.setMimeType(I.extensionToMimeType(t))}return r}),i.materials=(s.materials||[]).map(t=>{const e=n.createMaterial(t.name);t.extras&&e.setExtras(t.extras),void 0!==t.alphaMode&&e.setAlphaMode(t.alphaMode),void 0!==t.alphaCutoff&&e.setAlphaCutoff(t.alphaCutoff),void 0!==t.doubleSided&&e.setDoubleSided(t.doubleSided);const r=t.pbrMetallicRoughness||{};if(void 0!==r.baseColorFactor&&e.setBaseColorFactor(r.baseColorFactor),void 0!==t.emissiveFactor&&e.setEmissiveFactor(t.emissiveFactor),void 0!==r.metallicFactor&&e.setMetallicFactor(r.metallicFactor),void 0!==r.roughnessFactor&&e.setRoughnessFactor(r.roughnessFactor),void 0!==r.baseColorTexture){const t=r.baseColorTexture;e.setBaseColorTexture(i.textures[f[t.index].source]),i.setTextureInfo(e.getBaseColorTextureInfo(),t)}if(void 0!==t.emissiveTexture){const r=t.emissiveTexture;e.setEmissiveTexture(i.textures[f[r.index].source]),i.setTextureInfo(e.getEmissiveTextureInfo(),r)}if(void 0!==t.normalTexture){const r=t.normalTexture;e.setNormalTexture(i.textures[f[r.index].source]),i.setTextureInfo(e.getNormalTextureInfo(),r),void 0!==t.normalTexture.scale&&e.setNormalScale(t.normalTexture.scale)}if(void 0!==t.occlusionTexture){const r=t.occlusionTexture;e.setOcclusionTexture(i.textures[f[r.index].source]),i.setTextureInfo(e.getOcclusionTextureInfo(),r),void 0!==t.occlusionTexture.strength&&e.setOcclusionStrength(t.occlusionTexture.strength)}if(void 0!==r.metallicRoughnessTexture){const t=r.metallicRoughnessTexture;e.setMetallicRoughnessTexture(i.textures[f[t.index].source]),i.setTextureInfo(e.getMetallicRoughnessTextureInfo(),t)}return e});const d=s.meshes||[];n.getRoot().listExtensionsUsed().filter(t=>t.prereadTypes.includes(p.PRIMITIVE)).forEach(t=>t.preread(i,p.PRIMITIVE)),i.meshes=d.map(t=>{const e=n.createMesh(t.name);return t.extras&&e.setExtras(t.extras),void 0!==t.weights&&e.setWeights(t.weights),(t.primitives||[]).forEach(r=>{const s=n.createPrimitive();r.extras&&s.setExtras(r.extras),void 0!==r.material&&s.setMaterial(i.materials[r.material]),void 0!==r.mode&&s.setMode(r.mode);for(const[t,e]of Object.entries(r.attributes||{}))s.setAttribute(t,i.accessors[e]);void 0!==r.indices&&s.setIndices(i.accessors[r.indices]);const o=t.extras&&t.extras.targetNames||[];(r.targets||[]).forEach((t,e)=>{const r=o[e]||e.toString(),a=n.createPrimitiveTarget(r);for(const[e,r]of Object.entries(t))a.setAttribute(e,i.accessors[r]);s.addTarget(a)}),e.addPrimitive(s)}),e}),i.cameras=(s.cameras||[]).map(t=>{const e=n.createCamera(t.name).setType(t.type);if(t.extras&&e.setExtras(t.extras),t.type===Q.Type.PERSPECTIVE){const r=t.perspective;e.setYFov(r.yfov),e.setZNear(r.znear),void 0!==r.zfar&&e.setZFar(r.zfar),void 0!==r.aspectRatio&&e.setAspectRatio(r.aspectRatio)}else{const r=t.orthographic;e.setZNear(r.znear).setZFar(r.zfar).setXMag(r.xmag).setYMag(r.ymag)}return e});const g=s.nodes||[];n.getRoot().listExtensionsUsed().filter(t=>t.prereadTypes.includes(p.NODE)).forEach(t=>t.preread(i,p.NODE)),i.nodes=g.map(t=>{const e=n.createNode(t.name);if(t.extras&&e.setExtras(t.extras),void 0!==t.translation&&e.setTranslation(t.translation),void 0!==t.rotation&&e.setRotation(t.rotation),void 0!==t.scale&&e.setScale(t.scale),void 0!==t.matrix){const r=[0,0,0],s=[0,0,0,1],n=[1,1,1];F.decompose(t.matrix,r,s,n),e.setTranslation(r),e.setRotation(s),e.setScale(n)}return void 0!==t.weights&&e.setWeights(t.weights),e}),i.skins=(s.skins||[]).map(t=>{const e=n.createSkin(t.name);t.extras&&e.setExtras(t.extras),void 0!==t.inverseBindMatrices&&e.setInverseBindMatrices(i.accessors[t.inverseBindMatrices]),void 0!==t.skeleton&&e.setSkeleton(i.nodes[t.skeleton]);for(const r of t.joints)e.addJoint(i.nodes[r]);return e}),g.map((t,e)=>{const r=i.nodes[e];(t.children||[]).forEach(t=>r.addChild(i.nodes[t])),void 0!==t.mesh&&r.setMesh(i.meshes[t.mesh]),void 0!==t.camera&&r.setCamera(i.cameras[t.camera]),void 0!==t.skin&&r.setSkin(i.skins[t.skin])}),i.animations=(s.animations||[]).map(t=>{const e=n.createAnimation(t.name);t.extras&&e.setExtras(t.extras);const r=(t.samplers||[]).map(t=>{const r=n.createAnimationSampler().setInput(i.accessors[t.input]).setOutput(i.accessors[t.output]).setInterpolation(t.interpolation||Z.Interpolation.LINEAR);return t.extras&&r.setExtras(t.extras),e.addSampler(r),r});return(t.channels||[]).forEach(t=>{const s=n.createAnimationChannel().setSampler(r[t.sampler]).setTargetNode(i.nodes[t.target.node]).setTargetPath(t.target.path);t.extras&&s.setExtras(t.extras),e.addChannel(s)}),e});const m=s.scenes||[];return n.getRoot().listExtensionsUsed().filter(t=>t.prereadTypes.includes(p.SCENE)).forEach(t=>t.preread(i,p.SCENE)),i.scenes=m.map(t=>{const e=n.createScene(t.name);return t.extras&&e.setExtras(t.extras),(t.nodes||[]).map(t=>i.nodes[t]).forEach(t=>e.addChild(t)),e}),void 0!==s.scene&&n.getRoot().setDefaultScene(i.scenes[s.scene]),n.getRoot().listExtensionsUsed().forEach(t=>t.read(i)),n}static validate(t,e){const r=t.json;if("2.0"!==r.asset.version)throw new Error(`Unsupported glTF version, "${r.asset.version}".`);if(r.extensionsRequired)for(const t of r.extensionsRequired)if(!e.extensions.find(e=>e.EXTENSION_NAME===t))throw new Error(`Missing required extension, "${t}".`);if(r.extensionsUsed)for(const t of r.extensionsUsed)e.extensions.find(e=>e.EXTENSION_NAME===t)||e.logger.warn(`Missing optional extension, "${t}".`)}}.read(t,{extensions:Array.from(this.h),dependencies:this.C,logger:this.v})}async binaryToJSON(t){const e=this._(A.assertView(t));this.L(e);const r=e.json;if(r.buffers&&r.buffers.some(t=>function(t,e){return void 0!==e.uri&&!(e.uri in t.resources)}(e,t)))throw new Error("Cannot resolve external buffers with binaryToJSON().");if(r.images&&r.images.some(t=>function(t,e){return void 0!==e.uri&&!(e.uri in t.resources)&&void 0===e.bufferView}(e,t)))throw new Error("Cannot resolve external images with binaryToJSON().");return e}async readBinary(t){return this.readJSON(await this.binaryToJSON(A.assertView(t)))}async writeJSON(t,e={}){if(e.format===T.GLB&&t.getRoot().listBuffers().length>1)throw new Error("GLB must have 0–1 buffers.");return class{static write(t,e){const r=t.getRoot(),s={asset:ht({generator:"glTF-Transform v2.0.5"},r.getAsset()),extras:ht({},r.getExtras())},n={json:s,resources:{}},i=new bt(t,n,e),o=e.logger||C.DEFAULT_INSTANCE,a=new Set(e.extensions.map(t=>t.EXTENSION_NAME)),u=t.getRoot().listExtensionsUsed().filter(t=>a.has(t.extensionName)),c=t.getRoot().listExtensionsRequired().filter(t=>a.has(t.extensionName));u.length<t.getRoot().listExtensionsUsed().length&&o.debug("Some extensions were not registered for I/O, and will not be written.");for(const t of u)for(const r of t.writeDependencies)t.install(r,e.dependencies[r]);function h(t,e,r,n){const o=[];let a=0;for(const e of t){const t=i.createAccessorDef(e);t.bufferView=s.bufferViews.length;const r=e.getArray(),n=A.pad(A.toView(r));t.byteOffset=a,a+=n.byteLength,o.push(n),i.accessorIndexMap.set(e,s.accessors.length),s.accessors.push(t)}const u={buffer:e,byteOffset:r,byteLength:A.concat(o).byteLength};return n&&(u.target=n),s.bufferViews.push(u),{buffers:o,byteLength:a}}function l(t,e,r){const n=t[0].getCount();let o=0;for(const e of t){const t=i.createAccessorDef(e);t.bufferView=s.bufferViews.length,t.byteOffset=o;const r=e.getElementSize(),n=e.getComponentSize();o+=A.padNumber(r*n),i.accessorIndexMap.set(e,s.accessors.length),s.accessors.push(t)}const a=n*o,u=new ArrayBuffer(a),c=new DataView(u);for(let e=0;e<n;e++){let r=0;for(const s of t){const t=s.getElementSize(),n=s.getComponentSize(),i=s.getComponentType(),a=s.getArray();for(let s=0;s<t;s++){const u=e*o+r+s*n,h=a[e*t+s];switch(i){case W.ComponentType.FLOAT:c.setFloat32(u,h,!0);break;case W.ComponentType.BYTE:c.setInt8(u,h);break;case W.ComponentType.SHORT:c.setInt16(u,h,!0);break;case W.ComponentType.UNSIGNED_BYTE:c.setUint8(u,h);break;case W.ComponentType.UNSIGNED_SHORT:c.setUint16(u,h,!0);break;case W.ComponentType.UNSIGNED_INT:c.setUint32(u,h,!0);break;default:throw new Error("Unexpected component type: "+i)}}r+=A.padNumber(t*n)}}return s.bufferViews.push({buffer:e,byteOffset:r,byteLength:a,byteStride:o,target:bt.BufferViewTarget.ARRAY_BUFFER}),{byteLength:a,buffers:[new Uint8Array(u)]}}const f=new Map;for(const e of t.getGraph().listEdges()){if(e.getParent()===r)continue;const t=e.getChild();if(t instanceof W){const r=f.get(t)||[];r.push(e),f.set(t,r)}}if(s.accessors=[],s.bufferViews=[],s.samplers=[],s.textures=[],s.images=r.listTextures().map((t,e)=>{const r=i.createPropertyDef(t);t.getMimeType()&&(r.mimeType=t.getMimeType());const s=t.getImage();return s&&i.createImageData(r,s,t),i.imageIndexMap.set(t,e),r}),u.filter(t=>t.prewriteTypes.includes(p.ACCESSOR)).forEach(t=>t.prewrite(i,p.ACCESSOR)),r.listAccessors().forEach(t=>{const e=i.accessorUsageGroupedByParent,r=i.accessorParents;if(i.accessorIndexMap.has(t))return;const s=f.get(t)||[],n=i.getAccessorUsage(t);if(i.addAccessorToUsageGroup(t,n),e.has(n)){const e=s[0].getParent(),n=r.get(e)||new Set;n.add(t),r.set(e,n)}}),u.filter(t=>t.prewriteTypes.includes(p.BUFFER)).forEach(t=>t.prewrite(i,p.BUFFER)),(r.listAccessors().length>0||r.listTextures().length>0||i.otherBufferViews.size>0)&&0===r.listBuffers().length)throw new Error("Buffer required for Document resources, but none was found.");s.buffers=[],r.listBuffers().forEach((t,r)=>{const o=i.createPropertyDef(t),a=i.accessorUsageGroupedByParent,u=i.accessorParents,c=t.listParents().filter(t=>t instanceof W),f=new Set(c),d=[],g=s.buffers.length;let p=0;const w=i.listAccessorUsageGroups();for(const t in w)if(a.has(t))for(const r of Array.from(u.values())){const s=Array.from(r).filter(t=>f.has(t)).filter(e=>i.getAccessorUsage(e)===t);if(s.length)if(t!==Et.ARRAY_BUFFER||e.vertexLayout===m.INTERLEAVED){const e=t===Et.ARRAY_BUFFER?l(s,g,p):h(s,g,p);p+=e.byteLength,d.push(...e.buffers)}else for(const t of s){const e=l([t],g,p);p+=e.byteLength,d.push(...e.buffers)}}else{const e=w[t].filter(t=>f.has(t));if(!e.length)continue;const r=h(e,g,p,t===Et.ELEMENT_ARRAY_BUFFER?bt.BufferViewTarget.ELEMENT_ARRAY_BUFFER:void 0);p+=r.byteLength,d.push(...r.buffers)}if(i.imageBufferViews.length&&0===r)for(let t=0;t<i.imageBufferViews.length;t++)if(s.bufferViews[s.images[t].bufferView].byteOffset=p,p+=i.imageBufferViews[t].byteLength,d.push(i.imageBufferViews[t]),p%8){const t=8-p%8;p+=t,d.push(new Uint8Array(t))}if(i.otherBufferViews.has(t))for(const e of i.otherBufferViews.get(t))s.bufferViews.push({buffer:g,byteOffset:p,byteLength:e.byteLength}),i.otherBufferViewsIndexMap.set(e,s.bufferViews.length-1),p+=e.byteLength,d.push(e);if(p){let r;e.format===T.GLB?r="@glb.bin":(r=i.bufferURIGenerator.createURI(t,"bin"),o.uri=r),o.byteLength=p,n.resources[r]=A.concat(d)}s.buffers.push(o),i.bufferIndexMap.set(t,r)}),r.listAccessors().find(t=>!t.getBuffer())&&o.warn("Skipped writing one or more Accessors: no Buffer assigned."),s.materials=r.listMaterials().map((t,e)=>{const r=i.createPropertyDef(t);if(t.getAlphaMode()!==it.AlphaMode.OPAQUE&&(r.alphaMode=t.getAlphaMode()),t.getAlphaMode()===it.AlphaMode.MASK&&(r.alphaCutoff=t.getAlphaCutoff()),t.getDoubleSided()&&(r.doubleSided=!0),r.pbrMetallicRoughness={},F.eq(t.getBaseColorFactor(),[1,1,1,1])||(r.pbrMetallicRoughness.baseColorFactor=t.getBaseColorFactor()),F.eq(t.getEmissiveFactor(),[0,0,0])||(r.emissiveFactor=t.getEmissiveFactor()),1!==t.getRoughnessFactor()&&(r.pbrMetallicRoughness.roughnessFactor=t.getRoughnessFactor()),1!==t.getMetallicFactor()&&(r.pbrMetallicRoughness.metallicFactor=t.getMetallicFactor()),t.getBaseColorTexture()){const e=t.getBaseColorTexture(),s=t.getBaseColorTextureInfo();r.pbrMetallicRoughness.baseColorTexture=i.createTextureInfoDef(e,s)}if(t.getEmissiveTexture()){const e=t.getEmissiveTexture(),s=t.getEmissiveTextureInfo();r.emissiveTexture=i.createTextureInfoDef(e,s)}if(t.getNormalTexture()){const e=t.getNormalTexture(),s=t.getNormalTextureInfo(),n=i.createTextureInfoDef(e,s);1!==t.getNormalScale()&&(n.scale=t.getNormalScale()),r.normalTexture=n}if(t.getOcclusionTexture()){const e=t.getOcclusionTexture(),s=t.getOcclusionTextureInfo(),n=i.createTextureInfoDef(e,s);1!==t.getOcclusionStrength()&&(n.strength=t.getOcclusionStrength()),r.occlusionTexture=n}if(t.getMetallicRoughnessTexture()){const e=t.getMetallicRoughnessTexture(),s=t.getMetallicRoughnessTextureInfo();r.pbrMetallicRoughness.metallicRoughnessTexture=i.createTextureInfoDef(e,s)}return i.materialIndexMap.set(t,e),r}),s.meshes=r.listMeshes().map((t,e)=>{const r=i.createPropertyDef(t);let s=null;return r.primitives=t.listPrimitives().map(t=>{const e={attributes:{}};e.mode=t.getMode();const r=t.getMaterial();r&&(e.material=i.materialIndexMap.get(r)),Object.keys(t.getExtras()).length&&(e.extras=t.getExtras());const n=t.getIndices();n&&(e.indices=i.accessorIndexMap.get(n));for(const r of t.listSemantics())e.attributes[r]=i.accessorIndexMap.get(t.getAttribute(r));for(const r of t.listTargets()){const t={};for(const e of r.listSemantics())t[e]=i.accessorIndexMap.get(r.getAttribute(e));e.targets=e.targets||[],e.targets.push(t)}return t.listTargets().length&&!s&&(s=t.listTargets().map(t=>t.getName())),e}),t.getWeights().length&&(r.weights=t.getWeights()),s&&(r.extras=r.extras||{},r.extras.targetNames=s),i.meshIndexMap.set(t,e),r}),s.cameras=r.listCameras().map((t,e)=>{const r=i.createPropertyDef(t);if(r.type=t.getType(),r.type===Q.Type.PERSPECTIVE){r.perspective={znear:t.getZNear(),zfar:t.getZFar(),yfov:t.getYFov()};const e=t.getAspectRatio();null!==e&&(r.perspective.aspectRatio=e)}else r.orthographic={znear:t.getZNear(),zfar:t.getZFar(),xmag:t.getXMag(),ymag:t.getYMag()};return i.cameraIndexMap.set(t,e),r}),s.nodes=r.listNodes().map((t,e)=>{const r=i.createPropertyDef(t);return F.eq(t.getTranslation(),[0,0,0])||(r.translation=t.getTranslation()),F.eq(t.getRotation(),[0,0,0,1])||(r.rotation=t.getRotation()),F.eq(t.getScale(),[1,1,1])||(r.scale=t.getScale()),t.getWeights().length&&(r.weights=t.getWeights()),i.nodeIndexMap.set(t,e),r}),s.skins=r.listSkins().map((t,e)=>{const r=i.createPropertyDef(t),s=t.getInverseBindMatrices();s&&(r.inverseBindMatrices=i.accessorIndexMap.get(s));const n=t.getSkeleton();return n&&(r.skeleton=i.nodeIndexMap.get(n)),r.joints=t.listJoints().map(t=>i.nodeIndexMap.get(t)),i.skinIndexMap.set(t,e),r}),r.listNodes().forEach((t,e)=>{const r=s.nodes[e],n=t.getMesh();n&&(r.mesh=i.meshIndexMap.get(n));const o=t.getCamera();o&&(r.camera=i.cameraIndexMap.get(o));const a=t.getSkin();a&&(r.skin=i.skinIndexMap.get(a)),t.listChildren().length>0&&(r.children=t.listChildren().map(t=>i.nodeIndexMap.get(t)))}),s.animations=r.listAnimations().map((t,e)=>{const r=i.createPropertyDef(t),s=new Map;return r.samplers=t.listSamplers().map((t,e)=>{const r=i.createPropertyDef(t);return r.input=i.accessorIndexMap.get(t.getInput()),r.output=i.accessorIndexMap.get(t.getOutput()),r.interpolation=t.getInterpolation(),s.set(t,e),r}),r.channels=t.listChannels().map(t=>{const e=i.createPropertyDef(t);return e.sampler=s.get(t.getSampler()),e.target={node:i.nodeIndexMap.get(t.getTargetNode()),path:t.getTargetPath()},e}),i.animationIndexMap.set(t,e),r}),s.scenes=r.listScenes().map((t,e)=>{const r=i.createPropertyDef(t);return r.nodes=t.listChildren().map(t=>i.nodeIndexMap.get(t)),i.sceneIndexMap.set(t,e),r});const d=r.getDefaultScene();return d&&(s.scene=r.listScenes().indexOf(d)),s.extensionsUsed=u.map(t=>t.extensionName),s.extensionsRequired=c.map(t=>t.extensionName),u.forEach(t=>t.write(i)),function(t){const e=[];for(const r in t){const s=t[r];(Array.isArray(s)&&0===s.length||null===s||""===s||s&&"object"==typeof s&&0===Object.keys(s).length)&&e.push(r)}for(const r of e)delete t[r]}(s),n}}.write(t,{format:e.format||T.GLTF,basename:e.basename||"",logger:this.v,vertexLayout:this.F,dependencies:ht({},this.C),extensions:Array.from(this.h)})}async writeBinary(t){const{json:e,resources:r}=await this.writeJSON(t,{format:T.GLB}),s=new Uint32Array([1179937895,2,12]),n=JSON.stringify(e),i=A.pad(A.encodeText(n),32),o=A.toView(new Uint32Array([i.byteLength,1313821514])),a=A.concat([o,i]);s[s.length-1]+=a.byteLength;const u=Object.values(r)[0];if(!u||!u.byteLength)return A.concat([A.toView(s),a]);const c=A.pad(u,0),h=A.toView(new Uint32Array([c.byteLength,5130562])),l=A.concat([h,c]);return s[s.length-1]+=l.byteLength,A.concat([A.toView(s),a,l])}async P(t){this.lastReadBytes=0;const e=await this.readURI(t,"text");this.lastReadBytes+=e.length;const r={json:JSON.parse(e),resources:{}};return await this.D(r,this.dirname(t)),this.L(r),r}async U(t){const e=await this.readURI(t,"view");this.lastReadBytes=e.byteLength;const r=this._(e);return await this.D(r,this.dirname(t)),this.L(r),r}async D(t,e){var r=this;const s=[...t.json.images||[],...t.json.buffers||[]].map(async function(s){const n=s.uri;if(!n||n.match(/data:/))return Promise.resolve();t.resources[n]=await r.readURI(r.resolve(e,n),"view"),r.lastReadBytes+=t.resources[n].byteLength});await Promise.all(s)}L(t){function e(e){if(e.uri)if(e.uri in t.resources)A.assertView(t.resources[e.uri]);else if(e.uri.match(/data:/)){const r=`__${G()}.${S.extension(e.uri)}`;t.resources[r]=A.createBufferFromDataURI(e.uri),e.uri=r}}(t.json.images||[]).forEach(t=>{if(void 0===t.bufferView&&void 0===t.uri)throw new Error("Missing resource URI or buffer view.");e(t)}),(t.json.buffers||[]).forEach(e)}j(t){const{images:e,buffers:r}=t.json;return t={json:ht({},t.json),resources:ht({},t.resources)},e&&(t.json.images=e.map(t=>ht({},t))),r&&(t.json.buffers=r.map(t=>ht({},t))),t}_(t){const e=new Uint32Array(t.buffer,t.byteOffset,3);if(1179937895!==e[0])throw new Error("Invalid glTF asset.");if(2!==e[1])throw new Error(`Unsupported glTF binary version, "${e[1]}".`);const r=new Uint32Array(t.buffer,t.byteOffset+12,2);if(r[1]!==St.JSON)throw new Error("Missing required GLB JSON chunk.");const s=r[0],n=A.decodeText(A.toView(t,20,s)),i=JSON.parse(n),o=20+s;if(t.byteLength<=o)return{json:i,resources:{}};const a=new Uint32Array(t.buffer,t.byteOffset+o,2);if(a[1]!==St.BIN)throw new Error("Expected GLB BIN in second chunk.");return{json:i,resources:{"@glb.bin":A.toView(t,o+8,a[0])}}}}class It extends Mt{constructor(t=null,e=J.DEFAULT_INIT){super(),this.k=void 0,this.J=void 0,this.$=void 0,this.V=void 0,this.q=!1,this.k=(__webpack_require__(/*! fs */ "?b42e").promises),this.J=__webpack_require__(/*! path */ "?bf19"),this.$=t,this.V=e}setAllowHTTP(t){if(t&&!this.$)throw new Error("NodeIO requires a Fetch API implementation for HTTP requests.");return this.q=t,this}async readURI(t,e){if(J.isAbsoluteURL(t)){if(!this.q||!this.$)throw new Error("Network request blocked. Allow HTTP requests explicitly, if needed.");const r=await this.$(t,this.V);switch(e){case"view":return new Uint8Array(await r.arrayBuffer());case"text":return r.text()}}else switch(e){case"view":return this.k.readFile(t);case"text":return this.k.readFile(t,"utf8")}}resolve(t,e){return J.isAbsoluteURL(t)||J.isAbsoluteURL(e)?J.resolve(t,e):this.J.resolve(t,e)}dirname(t){return J.isAbsoluteURL(t)?J.dirname(t):this.J.dirname(t)}async write(t,e){const r=!!t.match(/\.glb$/);await(r?this.W(t,e):this.H(t,e))}async H(t,e){var r=this;this.lastWriteBytes=0;const{json:s,resources:n}=await this.writeJSON(e,{format:T.GLTF,basename:S.basename(t)}),{k:i,J:o}=this,a=o.dirname(t),u=JSON.stringify(s,null,2);this.lastWriteBytes+=u.length,await i.writeFile(t,u);const c=Object.keys(n).map(async function(t){if(J.isAbsoluteURL(t)){if("bin"===S.extension(t))throw new Error(`Cannot write buffer to path "${t}".`);return}const e=Buffer.from(n[t]);await i.writeFile(o.join(a,t),e),r.lastWriteBytes+=e.byteLength});await Promise.all(c)}async W(t,e){const r=Buffer.from(await this.writeBinary(e));await this.k.writeFile(t,r),this.lastWriteBytes=r.byteLength}}class Rt extends Mt{constructor(t){super(),this.J=void 0,this.J=t}async readURI(t,e){switch(e){case"view":return Deno.readFile(t);case"text":return Deno.readTextFile(t)}}resolve(t,e){return this.J.resolve(t,e)}dirname(t){return this.J.dirname(t)}}class Nt extends Mt{constructor(t=J.DEFAULT_INIT){super(),this.V=void 0,this.V=t}async readURI(t,e){const r=await fetch(t,this.V);switch(e){case"view":return new Uint8Array(await r.arrayBuffer());case"text":return r.text()}}resolve(t,e){return J.resolve(t,e)}dirname(t){return J.dirname(t)}}
//# sourceMappingURL=core.modern.js.map


/***/ }),

/***/ "./node_modules/@gltf-transform/extensions/dist/extensions.modern.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@gltf-transform/extensions/dist/extensions.modern.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ALL_EXTENSIONS": () => (/* binding */ mt),
/* harmony export */   "Clearcoat": () => (/* binding */ fe),
/* harmony export */   "DracoMeshCompression": () => (/* binding */ ne),
/* harmony export */   "EmissiveStrength": () => (/* binding */ xe),
/* harmony export */   "INSTANCE_ATTRIBUTE": () => (/* binding */ E),
/* harmony export */   "IOR": () => (/* binding */ me),
/* harmony export */   "InstancedMesh": () => (/* binding */ N),
/* harmony export */   "KHRONOS_EXTENSIONS": () => (/* binding */ dt),
/* harmony export */   "Light": () => (/* binding */ ie),
/* harmony export */   "LightsPunctual": () => (/* binding */ ce),
/* harmony export */   "Mapping": () => (/* binding */ Ye),
/* harmony export */   "MappingList": () => (/* binding */ Qe),
/* harmony export */   "MaterialsClearcoat": () => (/* binding */ pe),
/* harmony export */   "MaterialsEmissiveStrength": () => (/* binding */ de),
/* harmony export */   "MaterialsIOR": () => (/* binding */ Ne),
/* harmony export */   "MaterialsPBRSpecularGlossiness": () => (/* binding */ Ce),
/* harmony export */   "MaterialsSheen": () => (/* binding */ je),
/* harmony export */   "MaterialsSpecular": () => (/* binding */ Pe),
/* harmony export */   "MaterialsTransmission": () => (/* binding */ Ke),
/* harmony export */   "MaterialsUnlit": () => (/* binding */ $e),
/* harmony export */   "MaterialsVariants": () => (/* binding */ Ze),
/* harmony export */   "MaterialsVolume": () => (/* binding */ rt),
/* harmony export */   "MeshGPUInstancing": () => (/* binding */ I),
/* harmony export */   "MeshQuantization": () => (/* binding */ ot),
/* harmony export */   "MeshoptCompression": () => (/* binding */ L),
/* harmony export */   "PBRSpecularGlossiness": () => (/* binding */ Ae),
/* harmony export */   "Packet": () => (/* binding */ gt),
/* harmony export */   "Sheen": () => (/* binding */ be),
/* harmony export */   "Specular": () => (/* binding */ He),
/* harmony export */   "TextureBasisu": () => (/* binding */ ct),
/* harmony export */   "TextureTransform": () => (/* binding */ ht),
/* harmony export */   "TextureWebP": () => (/* binding */ P),
/* harmony export */   "Transform": () => (/* binding */ ut),
/* harmony export */   "Transmission": () => (/* binding */ ke),
/* harmony export */   "Unlit": () => (/* binding */ ze),
/* harmony export */   "Variant": () => (/* binding */ We),
/* harmony export */   "Volume": () => (/* binding */ tt),
/* harmony export */   "XMP": () => (/* binding */ Tt)
/* harmony export */ });
/* harmony import */ var _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @gltf-transform/core */ "./node_modules/@gltf-transform/core/dist/core.modern.js");
/* harmony import */ var ktx_parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ktx-parse */ "./node_modules/ktx-parse/dist/ktx-parse.modern.js");
const E="INSTANCE_ATTRIBUTE";class N extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ExtensionProperty{init(){this.extensionName="EXT_mesh_gpu_instancing",this.propertyType="InstancedMesh",this.parentTypes=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.NODE]}getDefaults(){return Object.assign(super.getDefaults(),{attributes:{}})}getAttribute(e){return this.getRefMap("attributes",e)}setAttribute(e,t){return this.setRefMap("attributes",e,t,{usage:"INSTANCE_ATTRIBUTE"})}listAttributes(){return this.listRefMapValues("attributes")}listSemantics(){return this.listRefMapKeys("attributes")}}N.EXTENSION_NAME="EXT_mesh_gpu_instancing";const R="EXT_mesh_gpu_instancing";class I extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Extension{constructor(...e){super(...e),this.extensionName=R,this.provideTypes=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.NODE],this.prewriteTypes=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.ACCESSOR]}createInstancedMesh(){return new N(this.document.getGraph())}read(e){return(e.jsonDoc.json.nodes||[]).forEach((t,s)=>{if(!t.extensions||!t.extensions[R])return;const r=t.extensions[R],n=this.createInstancedMesh();for(const t in r.attributes)n.setAttribute(t,e.accessors[r.attributes[t]]);e.nodes[s].setExtension(R,n)}),this}prewrite(e){e.accessorUsageGroupedByParent.add("INSTANCE_ATTRIBUTE");for(const t of this.properties)for(const s of t.listAttributes())e.addAccessorToUsageGroup(s,"INSTANCE_ATTRIBUTE");return this}write(e){const t=e.jsonDoc;return this.document.getRoot().listNodes().forEach(s=>{const r=s.getExtension(R);if(r){const n=e.nodeIndexMap.get(s),o=t.json.nodes[n],i={attributes:{}};r.listSemantics().forEach(t=>{const s=r.getAttribute(t);i.attributes[t]=e.accessorIndexMap.get(s)}),o.extensions=o.extensions||{},o.extensions[R]=i}}),this}}function _(){return(_=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var s=arguments[t];for(var r in s)Object.prototype.hasOwnProperty.call(s,r)&&(e[r]=s[r])}return e}).apply(this,arguments)}var S,A,y;I.EXTENSION_NAME=R,function(e){e.QUANTIZE="quantize",e.FILTER="filter"}(S||(S={})),function(e){e.ATTRIBUTES="ATTRIBUTES",e.TRIANGLES="TRIANGLES",e.INDICES="INDICES"}(A||(A={})),function(e){e.NONE="NONE",e.OCTAHEDRAL="OCTAHEDRAL",e.QUATERNION="QUATERNION",e.EXPONENTIAL="EXPONENTIAL"}(y||(y={}));const{BYTE:C,SHORT:O,FLOAT:M}=_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Accessor.ComponentType,{normalize:w,denormalize:D}=_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.MathUtils;function b(e,t,s,n){const{filter:o,bits:i}=n,a={array:e.getArray(),byteStride:e.getElementSize()*e.getComponentSize(),componentType:e.getComponentType(),normalized:e.getNormalized()};if(s!==A.ATTRIBUTES)return a;if(o!==y.NONE){let s=e.getNormalized()?function(e){const t=e.getComponentType(),s=e.getArray(),r=new Float32Array(s.length);for(let e=0;e<s.length;e++)r[e]=D(s[e],t);return r}(e):new Float32Array(a.array);switch(o){case y.EXPONENTIAL:a.byteStride=4*e.getElementSize(),a.componentType=M,a.normalized=!1,a.array=t.encodeFilterExp(s,e.getCount(),a.byteStride,i);break;case y.OCTAHEDRAL:a.byteStride=i>8?8:4,a.componentType=i>8?O:C,a.normalized=!0,s=3===e.getElementSize()?function(e){const t=new Float32Array(4*e.length/3);for(let s=0,r=e.length/3;s<r;s++)t[4*s]=e[3*s],t[4*s+1]=e[3*s+1],t[4*s+2]=e[3*s+2];return t}(s):s,a.array=t.encodeFilterOct(s,e.getCount(),a.byteStride,i);break;case y.QUATERNION:a.byteStride=8,a.componentType=O,a.normalized=!0,a.array=t.encodeFilterQuat(s,e.getCount(),a.byteStride,i);break;default:throw new Error("Invalid filter.")}a.min=e.getMin([]),a.max=e.getMax([]),e.getNormalized()&&(a.min=a.min.map(t=>D(t,e.getComponentType())),a.max=a.max.map(t=>D(t,e.getComponentType()))),a.normalized&&(a.min=a.min.map(e=>w(e,a.componentType)),a.max=a.max.map(e=>w(e,a.componentType)))}else a.byteStride%4&&(a.array=function(e,t){const s=_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.BufferUtils.padNumber(e.BYTES_PER_ELEMENT*t)/e.BYTES_PER_ELEMENT,n=new e.constructor(e.length/t*s);for(let r=0;r*t<e.length;r++)for(let o=0;o<t;o++)n[r*s+o]=e[r*t+o];return n}(a.array,e.getElementSize()),a.byteStride=a.array.byteLength/e.getCount());return a}function F(e,t){return t===_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.WriterContext.BufferViewUsage.ELEMENT_ARRAY_BUFFER?e.listParents().some(e=>e instanceof _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Primitive&&e.getMode()===_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Primitive.Mode.TRIANGLES)?A.TRIANGLES:A.INDICES:A.ATTRIBUTES}function j(e,t){const s=t.getGraph().listParentEdges(e).filter(e=>!(e.getParent()instanceof _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Root));for(const t of s){const s=t.getName(),r=t.getAttributes().key||"";if("indices"===s)return{filter:y.NONE};if("attributes"===s){if("POSITION"===r)return{filter:y.NONE};if("TEXCOORD_0"===r)return{filter:y.NONE};if("NORMAL"===r)return{filter:y.OCTAHEDRAL,bits:8};if("TANGENT"===r)return{filter:y.OCTAHEDRAL,bits:8};if(r.startsWith("JOINTS_"))return{filter:y.NONE};if(r.startsWith("WEIGHTS_"))return{filter:y.NONE}}if("output"===s){const t=v(e);return"rotation"===t?{filter:y.QUATERNION,bits:16}:"translation"===t||"scale"===t?{filter:y.EXPONENTIAL,bits:12}:{filter:y.NONE}}if("input"===s)return{filter:y.NONE};if("inverseBindMatrices"===s)return{filter:y.NONE}}return{filter:y.NONE}}function v(e){for(const t of e.listParents())if(t instanceof _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.AnimationSampler)for(const e of t.listParents())if(e instanceof _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.AnimationChannel)return e.getTargetPath();return null}const B="EXT_meshopt_compression",G={method:S.QUANTIZE};class L extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Extension{constructor(...e){super(...e),this.extensionName=B,this.prereadTypes=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.BUFFER,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.PRIMITIVE],this.prewriteTypes=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.BUFFER,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.ACCESSOR],this.readDependencies=["meshopt.decoder"],this.writeDependencies=["meshopt.encoder"],this._decoder=null,this._decoderFallbackBufferMap=new Map,this._encoder=null,this._encoderOptions=G,this._encoderFallbackBuffer=null,this._encoderBufferViews={},this._encoderBufferViewData={},this._encoderBufferViewAccessors={}}install(e,t){return"meshopt.decoder"===e&&(this._decoder=t),"meshopt.encoder"===e&&(this._encoder=t),this}setEncoderOptions(e){return this._encoderOptions=_({},G,e),this}preread(e,s){if(!this._decoder){if(!this.isRequired())return this;throw new Error(`[${B}] Please install extension dependency, "meshopt.decoder".`)}if(!this._decoder.supported){if(!this.isRequired())return this;throw new Error(`[${B}]: Missing WASM support.`)}return s===_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.BUFFER?this._prereadBuffers(e):s===_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.PRIMITIVE&&this._prereadPrimitives(e),this}_prereadBuffers(e){const t=e.jsonDoc;(t.json.bufferViews||[]).forEach((s,n)=>{if(!s.extensions||!s.extensions[B])return;const o=s.extensions[B],i=o.byteOffset||0,a=o.byteLength||0,c=o.count,u=o.byteStride,l=new Uint8Array(c*u),f=t.json.buffers[s.buffer],g=_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.BufferUtils.toView(f.uri?t.resources[f.uri]:t.resources[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.GLB_BUFFER],i,a);this._decoder.decodeGltfBuffer(l,c,u,g,o.mode,o.filter),e.bufferViews[n]=l})}_prereadPrimitives(e){const t=e.jsonDoc;(t.json.bufferViews||[]).forEach(s=>{var r;s.extensions&&s.extensions[B]&&(r=t.json.buffers[s.buffer]).extensions&&r.extensions.EXT_meshopt_compression&&r.extensions.EXT_meshopt_compression.fallback&&this._decoderFallbackBufferMap.set(e.buffers[s.buffer],e.buffers[s.extensions[B].buffer])})}read(e){if(!this.isRequired())return this;for(const[e,t]of this._decoderFallbackBufferMap){for(const s of e.listParents())s instanceof _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Accessor&&s.swap(e,t);e.dispose()}return this}prewrite(e,s){return s===_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.ACCESSOR?this._prewriteAccessors(e):s===_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.BUFFER&&this._prewriteBuffers(e),this}_prewriteAccessors(e){const t=e.jsonDoc.json,s=this._encoder,r=this._encoderOptions,o=this.document.createBuffer(),i=this.document.getRoot().listBuffers().indexOf(o);this._encoderFallbackBuffer=o,this._encoderBufferViews={},this._encoderBufferViewData={},this._encoderBufferViewAccessors={};for(const o of this.document.getRoot().listAccessors()){if("weights"===v(o))continue;const a=e.getAccessorUsage(o),c=F(o,a),u=r.method===S.FILTER?j(o,this.document):{filter:y.NONE},l=b(o,s,c,u),{array:h,byteStride:f}=l,g=o.getBuffer();if(!g)throw new Error(`${B}: Missing buffer for accessor.`);const p=this.document.getRoot().listBuffers().indexOf(g),x=[a,c,u.filter,f,p].join(":");let T=this._encoderBufferViews[x],d=this._encoderBufferViewData[x],m=this._encoderBufferViewAccessors[x];T&&d||(m=this._encoderBufferViewAccessors[x]=[],d=this._encoderBufferViewData[x]=[],T=this._encoderBufferViews[x]={buffer:i,target:_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.WriterContext.USAGE_TO_TARGET[a],byteOffset:0,byteLength:0,byteStride:a===_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.WriterContext.BufferViewUsage.ARRAY_BUFFER?f:void 0,extensions:{[B]:{buffer:p,byteOffset:0,byteLength:0,mode:c,filter:u.filter!==y.NONE?u.filter:void 0,byteStride:f,count:0}}});const E=e.createAccessorDef(o);E.componentType=l.componentType,E.normalized=l.normalized,E.byteOffset=T.byteLength,E.min&&l.min&&(E.min=l.min),E.max&&l.max&&(E.max=l.max),e.accessorIndexMap.set(o,t.accessors.length),t.accessors.push(E),m.push(E),d.push(new Uint8Array(h.buffer,h.byteOffset,h.byteLength)),T.byteLength+=h.byteLength,T.extensions.EXT_meshopt_compression.count+=o.getCount()}}_prewriteBuffers(e){const t=this._encoder;for(const s in this._encoderBufferViews){const n=this._encoderBufferViews[s],o=this._encoderBufferViewData[s],i=this.document.getRoot().listBuffers()[n.extensions[B].buffer],a=e.otherBufferViews.get(i)||[],{count:c,byteStride:u,mode:l}=n.extensions[B],h=_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.BufferUtils.concat(o),f=t.encodeGltfBuffer(h,c,u,l),g=_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.BufferUtils.pad(f);n.extensions[B].byteLength=f.byteLength,o.length=0,o.push(g),a.push(g),e.otherBufferViews.set(i,a)}}write(e){let t=0;for(const s in this._encoderBufferViews){const n=this._encoderBufferViews[s],o=e.otherBufferViewsIndexMap.get(this._encoderBufferViewData[s][0]),i=this._encoderBufferViewAccessors[s];for(const e of i)e.bufferView=o;const a=e.jsonDoc.json.bufferViews[o],c=a.byteOffset||0;Object.assign(a,n),a.byteOffset=t,a.extensions[B].byteOffset=c,t+=_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.BufferUtils.padNumber(n.byteLength)}const s=this._encoderFallbackBuffer,n=e.bufferIndexMap.get(s),o=e.jsonDoc.json.buffers[n];return o.byteLength=t,o.extensions={[B]:{fallback:!0}},s.dispose(),this}}L.EXTENSION_NAME=B,L.EncoderMethod=S;const H="EXT_texture_webp";class U{match(e){return e.length>=12&&87===e[8]&&69===e[9]&&66===e[10]&&80===e[11]}getSize(e){const t=_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.BufferUtils.decodeText(e.slice(0,4)),s=_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.BufferUtils.decodeText(e.slice(8,12));if("RIFF"!==t||"WEBP"!==s)return null;const n=new DataView(e.buffer,e.byteOffset);let o=12;for(;o<n.byteLength;){const e=_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.BufferUtils.decodeText(new Uint8Array([n.getUint8(o),n.getUint8(o+1),n.getUint8(o+2),n.getUint8(o+3)])),t=n.getUint32(o+4,!0);if("VP8 "===e)return[16383&n.getInt16(o+14,!0),16383&n.getInt16(o+16,!0)];if("VP8L"===e){const e=n.getUint8(o+9),t=n.getUint8(o+10),s=n.getUint8(o+11);return[1+((63&t)<<8|e),1+((15&n.getUint8(o+12))<<10|s<<2|(192&t)>>6)]}o+=8+t+t%2}return null}getChannels(e){return 4}}class P extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Extension{constructor(...e){super(...e),this.extensionName=H,this.prereadTypes=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.TEXTURE]}static register(){_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ImageUtils.registerFormat("image/webp",new U)}preread(e){return(e.jsonDoc.json.textures||[]).forEach(e=>{e.extensions&&e.extensions[H]&&(e.source=e.extensions[H].source)}),this}read(e){return this}write(e){const t=e.jsonDoc;return this.document.getRoot().listTextures().forEach(s=>{if("image/webp"===s.getMimeType()){const r=e.imageIndexMap.get(s);(t.json.textures||[]).forEach(e=>{e.source===r&&(e.extensions=e.extensions||{},e.extensions[H]={source:e.source},delete e.source)})}}),this}}P.EXTENSION_NAME=H;const V="KHR_draco_mesh_compression";let k,X,K,z;function q(e,t){const s=new k.DecoderBuffer;try{if(s.Init(t,t.length),e.GetEncodedGeometryType(s)!==k.TRIANGULAR_MESH)throw new Error(`[${V}] Unknown geometry type.`);const r=new k.Mesh;if(!e.DecodeBufferToMesh(s,r).ok()||0===r.ptr)throw new Error(`[${V}] Decoding failure.`);return r}finally{k.destroy(s)}}function $(e,t){const s=3*t.num_faces();let r,n;if(t.num_points()<=65534){const o=s*Uint16Array.BYTES_PER_ELEMENT;r=k._malloc(o),e.GetTrianglesUInt16Array(t,o,r),n=new Uint16Array(k.HEAPU16.buffer,r,s).slice()}else{const o=s*Uint32Array.BYTES_PER_ELEMENT;r=k._malloc(o),e.GetTrianglesUInt32Array(t,o,r),n=new Uint32Array(k.HEAPU32.buffer,r,s).slice()}return k._free(r),n}function Y(e,t,s,r){const n=K[r.componentType],o=X[r.componentType],i=s.num_components(),a=t.num_points()*i,c=a*o.BYTES_PER_ELEMENT,u=k._malloc(c);e.GetAttributeDataArrayForAllPoints(t,s,n,c,u);const l=new o(k.HEAPF32.buffer,u,a).slice();return k._free(u),l}var Q,W;!function(e){e[e.EDGEBREAKER=1]="EDGEBREAKER",e[e.SEQUENTIAL=0]="SEQUENTIAL"}(Q||(Q={})),function(e){e.POSITION="POSITION",e.NORMAL="NORMAL",e.COLOR="COLOR",e.TEX_COORD="TEX_COORD",e.GENERIC="GENERIC"}(W||(W={}));const J={[W.POSITION]:14,[W.NORMAL]:10,[W.COLOR]:8,[W.TEX_COORD]:12,[W.GENERIC]:12},Z={decodeSpeed:5,encodeSpeed:5,method:Q.EDGEBREAKER,quantizationBits:J,quantizationVolume:"mesh"};function ee(e,t=Z){const s=_({},Z,t);s.quantizationBits=_({},J,t.quantizationBits);const r=new z.Encoder,n=new z.MeshBuilder,o=new z.Mesh,i={},a=new z.DracoInt8Array;for(const t of e.listSemantics()){const a=e.getAttribute(t),c=te(t),u=se(n,a.getComponentType(),o,z[c],a.getCount(),a.getElementSize(),a.getArray());if(-1===u)throw new Error(`Error compressing "${t}" attribute.`);if(i[t]=u,"mesh"===s.quantizationVolume||"POSITION"!==t)r.SetAttributeQuantization(z[c],s.quantizationBits[c]);else{if("object"!=typeof s.quantizationVolume)throw new Error("Invalid quantization volume state.");{const{quantizationVolume:e}=s,t=Math.max(e.max[0]-e.min[0],e.max[1]-e.min[1],e.max[2]-e.min[2]);r.SetAttributeExplicitQuantization(z[c],s.quantizationBits[c],a.getElementSize(),e.min,t)}}}const c=e.getIndices();if(!c)throw new Error("Primitive must have indices.");n.AddFacesToMesh(o,c.getCount()/3,c.getArray()),r.SetSpeedOptions(s.encodeSpeed,s.decodeSpeed),r.SetTrackEncodedProperties(!0),s.method===Q.SEQUENTIAL||e.listTargets().length>0?r.SetEncodingMethod(z.MESH_SEQUENTIAL_ENCODING):r.SetEncodingMethod(z.MESH_EDGEBREAKER_ENCODING);const u=r.EncodeMeshToDracoBuffer(o,a);if(u<=0)throw new Error("Error applying Draco compression.");const l=new Uint8Array(u);for(let e=0;e<u;++e)l[e]=a.GetValue(e);const h=e.getAttribute("POSITION").getCount(),f=r.GetNumberOfEncodedPoints(),g=3*r.GetNumberOfEncodedFaces();if(e.listTargets().length>0&&f!==h)throw new Error('Compression reduced vertex count unexpectedly, corrupting morph targets. Applying the "weld" function before compression may resolve the issue.');return z.destroy(a),z.destroy(o),z.destroy(n),z.destroy(r),{numVertices:f,numIndices:g,data:l,attributeIDs:i}}function te(e){return"POSITION"===e?W.POSITION:"NORMAL"===e?W.NORMAL:e.startsWith("COLOR_")?W.COLOR:e.startsWith("TEXCOORD_")?W.TEX_COORD:W.GENERIC}function se(e,t,s,r,n,o,i){switch(t){case _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Accessor.ComponentType.UNSIGNED_BYTE:return e.AddUInt8Attribute(s,r,n,o,i);case _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Accessor.ComponentType.BYTE:return e.AddInt8Attribute(s,r,n,o,i);case _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Accessor.ComponentType.UNSIGNED_SHORT:return e.AddUInt16Attribute(s,r,n,o,i);case _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Accessor.ComponentType.SHORT:return e.AddInt16Attribute(s,r,n,o,i);case _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Accessor.ComponentType.UNSIGNED_INT:return e.AddUInt32Attribute(s,r,n,o,i);case _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Accessor.ComponentType.FLOAT:return e.AddFloatAttribute(s,r,n,o,i);default:throw new Error(`Unexpected component type, "${t}".`)}}const re="KHR_draco_mesh_compression";class ne extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Extension{constructor(...e){super(...e),this.extensionName=re,this.prereadTypes=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.PRIMITIVE],this.prewriteTypes=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.ACCESSOR],this.readDependencies=["draco3d.decoder"],this.writeDependencies=["draco3d.encoder"],this._decoderModule=null,this._encoderModule=null,this._encoderOptions={}}install(e,t){return"draco3d.decoder"===e&&(this._decoderModule=t,k=this._decoderModule,X={[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Accessor.ComponentType.FLOAT]:Float32Array,[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Accessor.ComponentType.UNSIGNED_INT]:Uint32Array,[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Accessor.ComponentType.UNSIGNED_SHORT]:Uint16Array,[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Accessor.ComponentType.UNSIGNED_BYTE]:Uint8Array,[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Accessor.ComponentType.SHORT]:Int16Array,[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Accessor.ComponentType.BYTE]:Int8Array},K={[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Accessor.ComponentType.FLOAT]:k.DT_FLOAT32,[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Accessor.ComponentType.UNSIGNED_INT]:k.DT_UINT32,[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Accessor.ComponentType.UNSIGNED_SHORT]:k.DT_UINT16,[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Accessor.ComponentType.UNSIGNED_BYTE]:k.DT_UINT8,[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Accessor.ComponentType.SHORT]:k.DT_INT16,[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Accessor.ComponentType.BYTE]:k.DT_INT8}),"draco3d.encoder"===e&&(this._encoderModule=t,z=this._encoderModule),this}setEncoderOptions(e){return this._encoderOptions=e,this}preread(e){if(!this._decoderModule)throw new Error(`[${re}] Please install extension dependency, "draco3d.decoder".`);const t=this.document.getLogger(),s=e.jsonDoc,n=new Map;try{const o=s.json.meshes||[];for(const i of o)for(const o of i.primitives){if(!o.extensions||!o.extensions[re])continue;const i=o.extensions[re];let[a,c]=n.get(i.bufferView)||[];if(!c||!a){const e=s.json.bufferViews[i.bufferView],o=s.json.buffers[e.buffer],u=_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.BufferUtils.toView(o.uri?s.resources[o.uri]:s.resources[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.GLB_BUFFER],e.byteOffset||0,e.byteLength);a=new this._decoderModule.Decoder,c=q(a,u),n.set(i.bufferView,[a,c]),t.debug(`[${re}] Decompressed ${u.byteLength} bytes.`)}for(const t in o.attributes){const s=e.jsonDoc.json.accessors[o.attributes[t]],r=a.GetAttributeByUniqueId(c,i.attributes[t]),n=Y(a,c,r,s);e.accessors[o.attributes[t]].setArray(n)}void 0!==o.indices&&e.accessors[o.indices].setArray($(a,c))}}finally{for(const[e,t]of Array.from(n.values()))this._decoderModule.destroy(e),this._decoderModule.destroy(t)}return this}read(e){return this}prewrite(e,s){if(!this._encoderModule)throw new Error(`[${re}] Please install extension dependency, "draco3d.encoder".`);const r=this.document.getLogger();r.debug(`[${re}] Compression options: ${JSON.stringify(this._encoderOptions)}`);const n=function(e){const s=e.getLogger(),r=new Set,n=new Set;for(const t of e.getRoot().listMeshes())for(const e of t.listPrimitives())e.getIndices()?e.getMode()!==_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Primitive.Mode.TRIANGLES?(n.add(e),s.warn(`[${re}] Skipping Draco compression on non-TRIANGLES primitive.`)):r.add(e):(n.add(e),s.warn(`[${re}] Skipping Draco compression on non-indexed primitive.`));const i=e.getRoot().listAccessors(),a=new Map;for(let e=0;e<i.length;e++)a.set(i[e],e);const c=new Map,u=new Set,l=new Map;for(const t of Array.from(r)){let s=oe(t,a);if(u.has(s))l.set(t,s);else{if(c.has(t.getIndices())){const s=t.getIndices(),r=s.clone();a.set(r,e.getRoot().listAccessors().length-1),t.swap(s,r)}for(const s of t.listAttributes())if(c.has(s)){const r=s.clone();a.set(r,e.getRoot().listAccessors().length-1),t.swap(s,r)}s=oe(t,a),u.add(s),l.set(t,s),c.set(t.getIndices(),s);for(const e of t.listAttributes())c.set(e,s)}}for(const e of Array.from(c.keys())){const s=new Set(e.listParents().map(e=>e.propertyType));if(2!==s.size||!s.has(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.PRIMITIVE)||!s.has(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.ROOT))throw new Error(`[${re}] Compressed accessors must only be used as indices or vertex attributes.`)}for(const e of Array.from(r)){const t=l.get(e),s=e.getIndices();if(c.get(s)!==t||e.listAttributes().some(e=>c.get(e)!==t))throw new Error(`[${re}] Draco primitives must share all, or no, accessors.`)}for(const e of Array.from(n)){const t=e.getIndices();if(c.has(t)||e.listAttributes().some(e=>c.has(e)))throw new Error(`[${re}] Accessor cannot be shared by compressed and uncompressed primitives.`)}return l}(this.document),i=new Map;let a="mesh";"scene"===this._encoderOptions.quantizationVolume&&(1!==this.document.getRoot().listScenes().length?r.warn(`[${re}]: quantizationVolume=scene requires exactly 1 scene.`):a=(0,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.bounds)(this.document.getRoot().listScenes().pop()));for(const t of Array.from(n.keys())){const s=n.get(t);if(!s)throw new Error("Unexpected primitive.");if(i.has(s)){i.set(s,i.get(s));continue}const r=t.getIndices(),o=e.jsonDoc.json.accessors,c=ee(t,_({},this._encoderOptions,{quantizationVolume:a}));i.set(s,c);const u=e.createAccessorDef(r);u.count=c.numIndices,e.accessorIndexMap.set(r,o.length),o.push(u);for(const s of t.listSemantics()){const r=t.getAttribute(s),n=e.createAccessorDef(r);n.count=c.numVertices,e.accessorIndexMap.set(r,o.length),o.push(n)}const l=t.getAttribute("POSITION").getBuffer()||this.document.getRoot().listBuffers()[0];e.otherBufferViews.has(l)||e.otherBufferViews.set(l,[]),e.otherBufferViews.get(l).push(c.data)}return r.debug(`[${re}] Compressed ${n.size} primitives.`),e.extensionData[re]={primitiveHashMap:n,primitiveEncodingMap:i},this}write(e){const t=e.extensionData[re];for(const s of this.document.getRoot().listMeshes()){const r=e.jsonDoc.json.meshes[e.meshIndexMap.get(s)];for(let n=0;n<s.listPrimitives().length;n++){const o=s.listPrimitives()[n],i=r.primitives[n],a=t.primitiveHashMap.get(o);if(!a)continue;const c=t.primitiveEncodingMap.get(a);i.extensions=i.extensions||{},i.extensions[re]={bufferView:e.otherBufferViewsIndexMap.get(c.data),attributes:c.attributeIDs}}}if(!t.primitiveHashMap.size){const t=e.jsonDoc.json;t.extensionsUsed=(t.extensionsUsed||[]).filter(e=>e!==re),t.extensionsRequired=(t.extensionsRequired||[]).filter(e=>e!==re)}return this}}function oe(e,t){const s=[],r=e.getIndices();s.push(t.get(r));for(const r of e.listAttributes())s.push(t.get(r));return s.sort().join("|")}ne.EXTENSION_NAME=re,ne.EncoderMethod=Q;class ie extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ExtensionProperty{init(){this.extensionName="KHR_lights_punctual",this.propertyType="Light",this.parentTypes=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.NODE]}getDefaults(){return Object.assign(super.getDefaults(),{color:[1,1,1],intensity:1,type:ie.Type.POINT,range:null,innerConeAngle:0,outerConeAngle:Math.PI/4})}getColor(){return this.get("color")}setColor(e){return this.set("color",e)}getColorHex(){return _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ColorUtils.factorToHex(this.getColor())}setColorHex(e){const t=this.getColor().slice();return _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ColorUtils.hexToFactor(e,t),this.setColor(t)}getIntensity(){return this.get("intensity")}setIntensity(e){return this.set("intensity",e)}getType(){return this.get("type")}setType(e){return this.set("type",e)}getRange(){return this.get("range")}setRange(e){return this.set("range",e)}getInnerConeAngle(){return this.get("innerConeAngle")}setInnerConeAngle(e){return this.set("innerConeAngle",e)}getOuterConeAngle(){return this.get("outerConeAngle")}setOuterConeAngle(e){return this.set("outerConeAngle",e)}}ie.EXTENSION_NAME="KHR_lights_punctual",ie.Type={POINT:"point",SPOT:"spot",DIRECTIONAL:"directional"};const ae="KHR_lights_punctual";class ce extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Extension{constructor(...e){super(...e),this.extensionName=ae}createLight(e=""){return new ie(this.document.getGraph(),e)}read(e){const t=e.jsonDoc;if(!t.json.extensions||!t.json.extensions[ae])return this;const s=(t.json.extensions[ae].lights||[]).map(e=>{var t,s;const r=this.createLight().setName(e.name||"").setType(e.type);return void 0!==e.color&&r.setColor(e.color),void 0!==e.intensity&&r.setIntensity(e.intensity),void 0!==e.range&&r.setRange(e.range),void 0!==(null==(t=e.spot)?void 0:t.innerConeAngle)&&r.setInnerConeAngle(e.spot.innerConeAngle),void 0!==(null==(s=e.spot)?void 0:s.outerConeAngle)&&r.setOuterConeAngle(e.spot.outerConeAngle),r});return t.json.nodes.forEach((t,r)=>{t.extensions&&t.extensions[ae]&&e.nodes[r].setExtension(ae,s[t.extensions[ae].light])}),this}write(e){const t=e.jsonDoc;if(0===this.properties.size)return this;const s=[],r=new Map;for(const e of this.properties){const t=e,n={type:t.getType()};_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.MathUtils.eq(t.getColor(),[1,1,1])||(n.color=t.getColor()),1!==t.getIntensity()&&(n.intensity=t.getIntensity()),null!=t.getRange()&&(n.range=t.getRange()),t.getName()&&(n.name=t.getName()),t.getType()===ie.Type.SPOT&&(n.spot={innerConeAngle:t.getInnerConeAngle(),outerConeAngle:t.getOuterConeAngle()}),s.push(n),r.set(t,s.length-1)}return this.document.getRoot().listNodes().forEach(s=>{const n=s.getExtension(ae);if(n){const o=e.nodeIndexMap.get(s),i=t.json.nodes[o];i.extensions=i.extensions||{},i.extensions[ae]={light:r.get(n)}}}),t.json.extensions=t.json.extensions||{},t.json.extensions[ae]={lights:s},this}}ce.EXTENSION_NAME=ae;const{R:ue,G:le,B:he}=_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.TextureChannel;class fe extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ExtensionProperty{init(){this.extensionName="KHR_materials_clearcoat",this.propertyType="Clearcoat",this.parentTypes=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{clearcoatFactor:0,clearcoatTexture:null,clearcoatTextureInfo:new _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.TextureInfo(this.graph,"clearcoatTextureInfo"),clearcoatRoughnessFactor:0,clearcoatRoughnessTexture:null,clearcoatRoughnessTextureInfo:new _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.TextureInfo(this.graph,"clearcoatRoughnessTextureInfo"),clearcoatNormalScale:1,clearcoatNormalTexture:null,clearcoatNormalTextureInfo:new _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.TextureInfo(this.graph,"clearcoatNormalTextureInfo")})}getClearcoatFactor(){return this.get("clearcoatFactor")}setClearcoatFactor(e){return this.set("clearcoatFactor",e)}getClearcoatTexture(){return this.getRef("clearcoatTexture")}getClearcoatTextureInfo(){return this.getRef("clearcoatTexture")?this.getRef("clearcoatTextureInfo"):null}setClearcoatTexture(e){return this.setRef("clearcoatTexture",e,{channels:ue})}getClearcoatRoughnessFactor(){return this.get("clearcoatRoughnessFactor")}setClearcoatRoughnessFactor(e){return this.set("clearcoatRoughnessFactor",e)}getClearcoatRoughnessTexture(){return this.getRef("clearcoatRoughnessTexture")}getClearcoatRoughnessTextureInfo(){return this.getRef("clearcoatRoughnessTexture")?this.getRef("clearcoatRoughnessTextureInfo"):null}setClearcoatRoughnessTexture(e){return this.setRef("clearcoatRoughnessTexture",e,{channels:le})}getClearcoatNormalScale(){return this.get("clearcoatNormalScale")}setClearcoatNormalScale(e){return this.set("clearcoatNormalScale",e)}getClearcoatNormalTexture(){return this.getRef("clearcoatNormalTexture")}getClearcoatNormalTextureInfo(){return this.getRef("clearcoatNormalTexture")?this.getRef("clearcoatNormalTextureInfo"):null}setClearcoatNormalTexture(e){return this.setRef("clearcoatNormalTexture",e,{channels:ue|le|he})}}fe.EXTENSION_NAME="KHR_materials_clearcoat";const ge="KHR_materials_clearcoat";class pe extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Extension{constructor(...e){super(...e),this.extensionName=ge}createClearcoat(){return new fe(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[ge]){const n=this.createClearcoat();e.materials[r].setExtension(ge,n);const o=t.extensions[ge];if(void 0!==o.clearcoatFactor&&n.setClearcoatFactor(o.clearcoatFactor),void 0!==o.clearcoatRoughnessFactor&&n.setClearcoatRoughnessFactor(o.clearcoatRoughnessFactor),void 0!==o.clearcoatTexture){const t=o.clearcoatTexture;n.setClearcoatTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getClearcoatTextureInfo(),t)}if(void 0!==o.clearcoatRoughnessTexture){const t=o.clearcoatRoughnessTexture;n.setClearcoatRoughnessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getClearcoatRoughnessTextureInfo(),t)}if(void 0!==o.clearcoatNormalTexture){const t=o.clearcoatNormalTexture;n.setClearcoatNormalTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getClearcoatNormalTextureInfo(),t),void 0!==t.scale&&n.setClearcoatNormalScale(t.scale)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(ge);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[ge]={clearcoatFactor:r.getClearcoatFactor(),clearcoatRoughnessFactor:r.getClearcoatRoughnessFactor()};if(r.getClearcoatTexture()){const t=r.getClearcoatTexture(),s=r.getClearcoatTextureInfo();i.clearcoatTexture=e.createTextureInfoDef(t,s)}if(r.getClearcoatRoughnessTexture()){const t=r.getClearcoatRoughnessTexture(),s=r.getClearcoatRoughnessTextureInfo();i.clearcoatRoughnessTexture=e.createTextureInfoDef(t,s)}if(r.getClearcoatNormalTexture()){const t=r.getClearcoatNormalTexture(),s=r.getClearcoatNormalTextureInfo();i.clearcoatNormalTexture=e.createTextureInfoDef(t,s),1!==r.getClearcoatNormalScale()&&(i.clearcoatNormalTexture.scale=r.getClearcoatNormalScale())}}}),this}}pe.EXTENSION_NAME=ge;class xe extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ExtensionProperty{init(){this.extensionName="KHR_materials_emissive_strength",this.propertyType="EmissiveStrength",this.parentTypes=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{emissiveStrength:1})}getEmissiveStrength(){return this.get("emissiveStrength")}setEmissiveStrength(e){return this.set("emissiveStrength",e)}}xe.EXTENSION_NAME="KHR_materials_emissive_strength";const Te="KHR_materials_emissive_strength";class de extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Extension{constructor(...e){super(...e),this.extensionName=Te}createEmissiveStrength(){return new xe(this.document.getGraph())}read(e){return(e.jsonDoc.json.materials||[]).forEach((t,s)=>{if(t.extensions&&t.extensions[Te]){const r=this.createEmissiveStrength();e.materials[s].setExtension(Te,r);const n=t.extensions[Te];void 0!==n.emissiveStrength&&r.setEmissiveStrength(n.emissiveStrength)}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(Te);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{},o.extensions[Te]={emissiveStrength:r.getEmissiveStrength()}}}),this}}de.EXTENSION_NAME=Te;class me extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ExtensionProperty{init(){this.extensionName="KHR_materials_ior",this.propertyType="IOR",this.parentTypes=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{ior:0})}getIOR(){return this.get("ior")}setIOR(e){return this.set("ior",e)}}me.EXTENSION_NAME="KHR_materials_ior";const Ee="KHR_materials_ior";class Ne extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Extension{constructor(...e){super(...e),this.extensionName=Ee}createIOR(){return new me(this.document.getGraph())}read(e){return(e.jsonDoc.json.materials||[]).forEach((t,s)=>{if(t.extensions&&t.extensions[Ee]){const r=this.createIOR();e.materials[s].setExtension(Ee,r);const n=t.extensions[Ee];void 0!==n.ior&&r.setIOR(n.ior)}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(Ee);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{},o.extensions[Ee]={ior:r.getIOR()}}}),this}}Ne.EXTENSION_NAME=Ee;const{R:Re,G:Ie,B:_e,A:Se}=_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.TextureChannel;class Ae extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ExtensionProperty{init(){this.extensionName="KHR_materials_pbrSpecularGlossiness",this.propertyType="PBRSpecularGlossiness",this.parentTypes=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{diffuseFactor:[1,1,1,1],diffuseTexture:null,diffuseTextureInfo:new _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.TextureInfo(this.graph,"diffuseTextureInfo"),specularFactor:[1,1,1],glossinessFactor:1,specularGlossinessTexture:null,specularGlossinessTextureInfo:new _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.TextureInfo(this.graph,"specularGlossinessTextureInfo")})}getDiffuseFactor(){return this.get("diffuseFactor")}setDiffuseFactor(e){return this.set("diffuseFactor",e)}getDiffuseHex(){return _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ColorUtils.factorToHex(this.getDiffuseFactor())}setDiffuseHex(e){const t=this.getDiffuseFactor().slice();return this.setDiffuseFactor(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ColorUtils.hexToFactor(e,t))}getDiffuseTexture(){return this.getRef("diffuseTexture")}getDiffuseTextureInfo(){return this.getRef("diffuseTexture")?this.getRef("diffuseTextureInfo"):null}setDiffuseTexture(e){return this.setRef("diffuseTexture",e,{channels:Re|Ie|_e|Se})}getSpecularFactor(){return this.get("specularFactor")}setSpecularFactor(e){return this.set("specularFactor",e)}getGlossinessFactor(){return this.get("glossinessFactor")}setGlossinessFactor(e){return this.set("glossinessFactor",e)}getSpecularGlossinessTexture(){return this.getRef("specularGlossinessTexture")}getSpecularGlossinessTextureInfo(){return this.getRef("specularGlossinessTexture")?this.getRef("specularGlossinessTextureInfo"):null}setSpecularGlossinessTexture(e){return this.setRef("specularGlossinessTexture",e,{channels:Re|Ie|_e|Se})}}Ae.EXTENSION_NAME="KHR_materials_pbrSpecularGlossiness";const ye="KHR_materials_pbrSpecularGlossiness";class Ce extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Extension{constructor(...e){super(...e),this.extensionName=ye}createPBRSpecularGlossiness(){return new Ae(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[ye]){const n=this.createPBRSpecularGlossiness();e.materials[r].setExtension(ye,n);const o=t.extensions[ye];if(void 0!==o.diffuseFactor&&n.setDiffuseFactor(o.diffuseFactor),void 0!==o.specularFactor&&n.setSpecularFactor(o.specularFactor),void 0!==o.glossinessFactor&&n.setGlossinessFactor(o.glossinessFactor),void 0!==o.diffuseTexture){const t=o.diffuseTexture;n.setDiffuseTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getDiffuseTextureInfo(),t)}if(void 0!==o.specularGlossinessTexture){const t=o.specularGlossinessTexture;n.setSpecularGlossinessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSpecularGlossinessTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(ye);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[ye]={diffuseFactor:r.getDiffuseFactor(),specularFactor:r.getSpecularFactor(),glossinessFactor:r.getGlossinessFactor()};if(r.getDiffuseTexture()){const t=r.getDiffuseTexture(),s=r.getDiffuseTextureInfo();i.diffuseTexture=e.createTextureInfoDef(t,s)}if(r.getSpecularGlossinessTexture()){const t=r.getSpecularGlossinessTexture(),s=r.getSpecularGlossinessTextureInfo();i.specularGlossinessTexture=e.createTextureInfoDef(t,s)}}}),this}}Ce.EXTENSION_NAME=ye;const{R:Oe,G:Me,B:we,A:De}=_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.TextureChannel;class be extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ExtensionProperty{init(){this.extensionName="KHR_materials_sheen",this.propertyType="Sheen",this.parentTypes=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{sheenColorFactor:[0,0,0],sheenColorTexture:null,sheenColorTextureInfo:new _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.TextureInfo(this.graph,"sheenColorTextureInfo"),sheenRoughnessFactor:0,sheenRoughnessTexture:null,sheenRoughnessTextureInfo:new _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.TextureInfo(this.graph,"sheenRoughnessTextureInfo")})}getSheenColorFactor(){return this.get("sheenColorFactor")}getSheenColorHex(){return _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ColorUtils.factorToHex(this.getSheenColorFactor())}setSheenColorFactor(e){return this.set("sheenColorFactor",e)}setSheenColorHex(e){const t=this.getSheenColorFactor().slice();return this.set("sheenColorFactor",_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ColorUtils.hexToFactor(e,t))}getSheenColorTexture(){return this.getRef("sheenColorTexture")}getSheenColorTextureInfo(){return this.getRef("sheenColorTexture")?this.getRef("sheenColorTextureInfo"):null}setSheenColorTexture(e){return this.setRef("sheenColorTexture",e,{channels:Oe|Me|we})}getSheenRoughnessFactor(){return this.get("sheenRoughnessFactor")}setSheenRoughnessFactor(e){return this.set("sheenRoughnessFactor",e)}getSheenRoughnessTexture(){return this.getRef("sheenRoughnessTexture")}getSheenRoughnessTextureInfo(){return this.getRef("sheenRoughnessTexture")?this.getRef("sheenRoughnessTextureInfo"):null}setSheenRoughnessTexture(e){return this.setRef("sheenRoughnessTexture",e,{channels:De})}}be.EXTENSION_NAME="KHR_materials_sheen";const Fe="KHR_materials_sheen";class je extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Extension{constructor(...e){super(...e),this.extensionName=Fe}createSheen(){return new be(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[Fe]){const n=this.createSheen();e.materials[r].setExtension(Fe,n);const o=t.extensions[Fe];if(void 0!==o.sheenColorFactor&&n.setSheenColorFactor(o.sheenColorFactor),void 0!==o.sheenRoughnessFactor&&n.setSheenRoughnessFactor(o.sheenRoughnessFactor),void 0!==o.sheenColorTexture){const t=o.sheenColorTexture;n.setSheenColorTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSheenColorTextureInfo(),t)}if(void 0!==o.sheenRoughnessTexture){const t=o.sheenRoughnessTexture;n.setSheenRoughnessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSheenRoughnessTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(Fe);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[Fe]={sheenColorFactor:r.getSheenColorFactor(),sheenRoughnessFactor:r.getSheenRoughnessFactor()};if(r.getSheenColorTexture()){const t=r.getSheenColorTexture(),s=r.getSheenColorTextureInfo();i.sheenColorTexture=e.createTextureInfoDef(t,s)}if(r.getSheenRoughnessTexture()){const t=r.getSheenRoughnessTexture(),s=r.getSheenRoughnessTextureInfo();i.sheenRoughnessTexture=e.createTextureInfoDef(t,s)}}}),this}}je.EXTENSION_NAME=Fe;const{R:ve,G:Be,B:Ge,A:Le}=_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.TextureChannel;class He extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ExtensionProperty{init(){this.extensionName="KHR_materials_specular",this.propertyType="Specular",this.parentTypes=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{specularFactor:1,specularTexture:null,specularTextureInfo:new _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.TextureInfo(this.graph,"specularTextureInfo"),specularColorFactor:[1,1,1],specularColorTexture:null,specularColorTextureInfo:new _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.TextureInfo(this.graph,"specularColorTextureInfo")})}getSpecularFactor(){return this.get("specularFactor")}setSpecularFactor(e){return this.set("specularFactor",e)}getSpecularColorFactor(){return this.get("specularColorFactor")}setSpecularColorFactor(e){return this.set("specularColorFactor",e)}getSpecularColorHex(){return _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ColorUtils.factorToHex(this.getSpecularColorFactor())}setSpecularColorHex(e){const t=this.getSpecularColorFactor().slice();return this.set("specularColorFactor",_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ColorUtils.hexToFactor(e,t))}getSpecularTexture(){return this.getRef("specularTexture")}getSpecularTextureInfo(){return this.getRef("specularTexture")?this.getRef("specularTextureInfo"):null}setSpecularTexture(e){return this.setRef("specularTexture",e,{channels:Le})}getSpecularColorTexture(){return this.getRef("specularColorTexture")}getSpecularColorTextureInfo(){return this.getRef("specularColorTexture")?this.getRef("specularColorTextureInfo"):null}setSpecularColorTexture(e){return this.setRef("specularColorTexture",e,{channels:ve|Be|Ge})}}He.EXTENSION_NAME="KHR_materials_specular";const Ue="KHR_materials_specular";class Pe extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Extension{constructor(...e){super(...e),this.extensionName=Ue}createSpecular(){return new He(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[Ue]){const n=this.createSpecular();e.materials[r].setExtension(Ue,n);const o=t.extensions[Ue];if(void 0!==o.specularFactor&&n.setSpecularFactor(o.specularFactor),void 0!==o.specularColorFactor&&n.setSpecularColorFactor(o.specularColorFactor),void 0!==o.specularTexture){const t=o.specularTexture;n.setSpecularTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSpecularTextureInfo(),t)}if(void 0!==o.specularColorTexture){const t=o.specularColorTexture;n.setSpecularColorTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getSpecularColorTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(Ue);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[Ue]={};if(1!==r.getSpecularFactor()&&(i.specularFactor=r.getSpecularFactor()),_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.MathUtils.eq(r.getSpecularColorFactor(),[1,1,1])||(i.specularColorFactor=r.getSpecularColorFactor()),r.getSpecularTexture()){const t=r.getSpecularTexture(),s=r.getSpecularTextureInfo();i.specularTexture=e.createTextureInfoDef(t,s)}if(r.getSpecularColorTexture()){const t=r.getSpecularColorTexture(),s=r.getSpecularColorTextureInfo();i.specularColorTexture=e.createTextureInfoDef(t,s)}}}),this}}Pe.EXTENSION_NAME=Ue;const{R:Ve}=_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.TextureChannel;class ke extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ExtensionProperty{init(){this.extensionName="KHR_materials_transmission",this.propertyType="Transmission",this.parentTypes=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{transmissionFactor:0,transmissionTexture:null,transmissionTextureInfo:new _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.TextureInfo(this.graph,"transmissionTextureInfo")})}getTransmissionFactor(){return this.get("transmissionFactor")}setTransmissionFactor(e){return this.set("transmissionFactor",e)}getTransmissionTexture(){return this.getRef("transmissionTexture")}getTransmissionTextureInfo(){return this.getRef("transmissionTexture")?this.getRef("transmissionTextureInfo"):null}setTransmissionTexture(e){return this.setRef("transmissionTexture",e,{channels:Ve})}}ke.EXTENSION_NAME="KHR_materials_transmission";const Xe="KHR_materials_transmission";class Ke extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Extension{constructor(...e){super(...e),this.extensionName=Xe}createTransmission(){return new ke(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[Xe]){const n=this.createTransmission();e.materials[r].setExtension(Xe,n);const o=t.extensions[Xe];if(void 0!==o.transmissionFactor&&n.setTransmissionFactor(o.transmissionFactor),void 0!==o.transmissionTexture){const t=o.transmissionTexture;n.setTransmissionTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getTransmissionTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(Xe);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[Xe]={transmissionFactor:r.getTransmissionFactor()};if(r.getTransmissionTexture()){const t=r.getTransmissionTexture(),s=r.getTransmissionTextureInfo();i.transmissionTexture=e.createTextureInfoDef(t,s)}}}),this}}Ke.EXTENSION_NAME=Xe;class ze extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ExtensionProperty{init(){this.extensionName="KHR_materials_unlit",this.propertyType="Unlit",this.parentTypes=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.MATERIAL]}}ze.EXTENSION_NAME="KHR_materials_unlit";const qe="KHR_materials_unlit";class $e extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Extension{constructor(...e){super(...e),this.extensionName=qe}createUnlit(){return new ze(this.document.getGraph())}read(e){return(e.jsonDoc.json.materials||[]).forEach((t,s)=>{t.extensions&&t.extensions[qe]&&e.materials[s].setExtension(qe,this.createUnlit())}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{if(s.getExtension(qe)){const r=e.materialIndexMap.get(s),n=t.json.materials[r];n.extensions=n.extensions||{},n.extensions[qe]={}}}),this}}$e.EXTENSION_NAME=qe;class Ye extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ExtensionProperty{init(){this.extensionName="KHR_materials_variants",this.propertyType="Mapping",this.parentTypes=["MappingList"]}getDefaults(){return Object.assign(super.getDefaults(),{material:null,variants:[]})}getMaterial(){return this.getRef("material")}setMaterial(e){return this.setRef("material",e)}addVariant(e){return this.addRef("variants",e)}removeVariant(e){return this.removeRef("variants",e)}listVariants(){return this.listRefs("variants")}}Ye.EXTENSION_NAME="KHR_materials_variants";class Qe extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ExtensionProperty{init(){this.extensionName="KHR_materials_variants",this.propertyType="MappingList",this.parentTypes=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.PRIMITIVE]}getDefaults(){return Object.assign(super.getDefaults(),{mappings:[]})}addMapping(e){return this.addRef("mappings",e)}removeMapping(e){return this.removeRef("mappings",e)}listMappings(){return this.listRefs("mappings")}}Qe.EXTENSION_NAME="KHR_materials_variants";class We extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ExtensionProperty{init(){this.extensionName="KHR_materials_variants",this.propertyType="Variant",this.parentTypes=["MappingList"]}}We.EXTENSION_NAME="KHR_materials_variants";const Je="KHR_materials_variants";class Ze extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Extension{constructor(...e){super(...e),this.extensionName=Je}createMappingList(){return new Qe(this.document.getGraph())}createVariant(e=""){return new We(this.document.getGraph(),e)}createMapping(){return new Ye(this.document.getGraph())}listVariants(){return Array.from(this.properties).filter(e=>e instanceof We)}read(e){const t=e.jsonDoc;if(!t.json.extensions||!t.json.extensions[Je])return this;const s=(t.json.extensions[Je].variants||[]).map(e=>this.createVariant().setName(e.name||""));return(t.json.meshes||[]).forEach((t,r)=>{const n=e.meshes[r];(t.primitives||[]).forEach((t,r)=>{if(!t.extensions||!t.extensions[Je])return;const o=this.createMappingList(),i=t.extensions[Je];for(const t of i.mappings){const r=this.createMapping();void 0!==t.material&&r.setMaterial(e.materials[t.material]);for(const e of t.variants||[])r.addVariant(s[e]);o.addMapping(r)}n.listPrimitives()[r].setExtension(Je,o)})}),this}write(e){const t=e.jsonDoc,s=this.listVariants();if(!s.length)return this;const r=[],n=new Map;for(const t of s)n.set(t,r.length),r.push(e.createPropertyDef(t));for(const t of this.document.getRoot().listMeshes()){const s=e.meshIndexMap.get(t);t.listPrimitives().forEach((t,r)=>{const o=t.getExtension(Je);if(!o)return;const i=e.jsonDoc.json.meshes[s].primitives[r],a=o.listMappings().map(t=>{const s=e.createPropertyDef(t),r=t.getMaterial();return r&&(s.material=e.materialIndexMap.get(r)),s.variants=t.listVariants().map(e=>n.get(e)),s});i.extensions=i.extensions||{},i.extensions[Je]={mappings:a}})}return t.json.extensions=t.json.extensions||{},t.json.extensions[Je]={variants:r},this}}Ze.EXTENSION_NAME=Je;const{G:et}=_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.TextureChannel;class tt extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ExtensionProperty{init(){this.extensionName="KHR_materials_volume",this.propertyType="Volume",this.parentTypes=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.MATERIAL]}getDefaults(){return Object.assign(super.getDefaults(),{thicknessFactor:0,thicknessTexture:null,thicknessTextureInfo:new _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.TextureInfo(this.graph,"thicknessTexture"),attenuationDistance:Infinity,attenuationColor:[1,1,1]})}getThicknessFactor(){return this.get("thicknessFactor")}setThicknessFactor(e){return this.set("thicknessFactor",e)}getThicknessTexture(){return this.getRef("thicknessTexture")}getThicknessTextureInfo(){return this.getRef("thicknessTexture")?this.getRef("thicknessTextureInfo"):null}setThicknessTexture(e){return this.setRef("thicknessTexture",e,{channels:et})}getAttenuationDistance(){return this.get("attenuationDistance")}setAttenuationDistance(e){return this.set("attenuationDistance",e)}getAttenuationColor(){return this.get("attenuationColor")}setAttenuationColor(e){return this.set("attenuationColor",e)}getAttenuationColorHex(){return _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ColorUtils.factorToHex(this.getAttenuationColor())}setAttenuationColorHex(e){const t=this.getAttenuationColor().slice();return this.set("attenuationColor",_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ColorUtils.hexToFactor(e,t))}}tt.EXTENSION_NAME="KHR_materials_volume";const st="KHR_materials_volume";class rt extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Extension{constructor(...e){super(...e),this.extensionName=st}createVolume(){return new tt(this.document.getGraph())}read(e){const t=e.jsonDoc,s=t.json.textures||[];return(t.json.materials||[]).forEach((t,r)=>{if(t.extensions&&t.extensions[st]){const n=this.createVolume();e.materials[r].setExtension(st,n);const o=t.extensions[st];if(void 0!==o.thicknessFactor&&n.setThicknessFactor(o.thicknessFactor),void 0!==o.attenuationDistance&&n.setAttenuationDistance(o.attenuationDistance),void 0!==o.attenuationColor&&n.setAttenuationColor(o.attenuationColor),void 0!==o.thicknessTexture){const t=o.thicknessTexture;n.setThicknessTexture(e.textures[s[t.index].source]),e.setTextureInfo(n.getThicknessTextureInfo(),t)}}}),this}write(e){const t=e.jsonDoc;return this.document.getRoot().listMaterials().forEach(s=>{const r=s.getExtension(st);if(r){const n=e.materialIndexMap.get(s),o=t.json.materials[n];o.extensions=o.extensions||{};const i=o.extensions[st]={};if(r.getThicknessFactor()>0&&(i.thicknessFactor=r.getThicknessFactor()),Number.isFinite(r.getAttenuationDistance())&&(i.attenuationDistance=r.getAttenuationDistance()),_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.MathUtils.eq(r.getAttenuationColor(),[1,1,1])||(i.attenuationColor=r.getAttenuationColor()),r.getThicknessTexture()){const t=r.getThicknessTexture(),s=r.getThicknessTextureInfo();i.thicknessTexture=e.createTextureInfoDef(t,s)}}}),this}}rt.EXTENSION_NAME=st;const nt="KHR_mesh_quantization";class ot extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Extension{constructor(...e){super(...e),this.extensionName=nt}read(e){return this}write(e){return this}}ot.EXTENSION_NAME=nt;const it="KHR_texture_basisu";class at{match(e){return 171===e[0]&&75===e[1]&&84===e[2]&&88===e[3]&&32===e[4]&&50===e[5]&&48===e[6]&&187===e[7]&&13===e[8]&&10===e[9]&&26===e[10]&&10===e[11]}getSize(e){const t=(0,ktx_parse__WEBPACK_IMPORTED_MODULE_0__.read)(e);return[t.pixelWidth,t.pixelHeight]}getChannels(e){const t=(0,ktx_parse__WEBPACK_IMPORTED_MODULE_0__.read)(e).dataFormatDescriptor[0];if(t.colorModel===ktx_parse__WEBPACK_IMPORTED_MODULE_0__.KTX2Model.ETC1S)return 2===t.samples.length&&15==(15&t.samples[1].channelID)?4:3;if(t.colorModel===ktx_parse__WEBPACK_IMPORTED_MODULE_0__.KTX2Model.UASTC)return 3==(15&t.samples[0].channelID)?4:3;throw new Error(`Unexpected KTX2 colorModel, "${t.colorModel}".`)}getGPUByteLength(e){const t=(0,ktx_parse__WEBPACK_IMPORTED_MODULE_0__.read)(e),s=this.getChannels(e)>3;let r=0;for(let e=0;e<t.levels.length;e++){const n=t.levels[e];r+=n.uncompressedByteLength?n.uncompressedByteLength:Math.max(1,Math.floor(t.pixelWidth/Math.pow(2,e)))/4*(Math.max(1,Math.floor(t.pixelHeight/Math.pow(2,e)))/4)*(s?16:8)}return r}}class ct extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Extension{constructor(...e){super(...e),this.extensionName=it,this.prereadTypes=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.TEXTURE]}static register(){_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ImageUtils.registerFormat("image/ktx2",new at)}preread(e){return e.jsonDoc.json.textures.forEach(e=>{e.extensions&&e.extensions[it]&&(e.source=e.extensions[it].source)}),this}read(e){return this}write(e){const t=e.jsonDoc;return this.document.getRoot().listTextures().forEach(s=>{if("image/ktx2"===s.getMimeType()){const r=e.imageIndexMap.get(s);t.json.textures.forEach(e=>{e.source===r&&(e.extensions=e.extensions||{},e.extensions[it]={source:e.source},delete e.source)})}}),this}}ct.EXTENSION_NAME=it;class ut extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ExtensionProperty{init(){this.extensionName="KHR_texture_transform",this.propertyType="Transform",this.parentTypes=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.TEXTURE_INFO]}getDefaults(){return Object.assign(super.getDefaults(),{offset:[0,0],rotation:0,scale:[1,1],texCoord:null})}getOffset(){return this.get("offset")}setOffset(e){return this.set("offset",e)}getRotation(){return this.get("rotation")}setRotation(e){return this.set("rotation",e)}getScale(){return this.get("scale")}setScale(e){return this.set("scale",e)}getTexCoord(){return this.get("texCoord")}setTexCoord(e){return this.set("texCoord",e)}}ut.EXTENSION_NAME="KHR_texture_transform";const lt="KHR_texture_transform";class ht extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Extension{constructor(...e){super(...e),this.extensionName=lt}createTransform(){return new ut(this.document.getGraph())}read(e){for(const[t,s]of Array.from(e.textureInfos.entries())){if(!s.extensions||!s.extensions[lt])continue;const e=this.createTransform(),r=s.extensions[lt];void 0!==r.offset&&e.setOffset(r.offset),void 0!==r.rotation&&e.setRotation(r.rotation),void 0!==r.scale&&e.setScale(r.scale),void 0!==r.texCoord&&e.setTexCoord(r.texCoord),t.setExtension(lt,e)}return this}write(e){const t=Array.from(e.textureInfoDefMap.entries());for(const[e,s]of t){const t=e.getExtension(lt);if(!t)continue;s.extensions=s.extensions||{};const r={},n=_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.MathUtils.eq;n(t.getOffset(),[0,0])||(r.offset=t.getOffset()),0!==t.getRotation()&&(r.rotation=t.getRotation()),n(t.getScale(),[1,1])||(r.scale=t.getScale()),null!=t.getTexCoord()&&(r.texCoord=t.getTexCoord()),s.extensions[lt]=r}return this}}ht.EXTENSION_NAME=lt;const ft=[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.ROOT,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.SCENE,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.NODE,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.MESH,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.MATERIAL,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.TEXTURE,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.ANIMATION];class gt extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.ExtensionProperty{init(){this.extensionName="KHR_xmp_json_ld",this.propertyType="Packet",this.parentTypes=ft}getDefaults(){return Object.assign(super.getDefaults(),{context:{},properties:{}})}getContext(){return this.get("context")}setContext(e){return this.set("context",_({},e))}listProperties(){return Object.keys(this.get("properties"))}getProperty(e){const t=this.get("properties");return e in t?t[e]:null}setProperty(e,t){this._assertContext(e);const s=_({},this.get("properties"));return t?s[e]=t:delete s[e],this.set("properties",s)}toJSONLD(){return _({"@context":pt(this.get("context"))},pt(this.get("properties")))}fromJSONLD(e){const t=(e=pt(e))["@context"];return t&&this.set("context",t),delete e["@context"],this.set("properties",e)}_assertContext(e){if(!(e.split(":")[0]in this.get("context")))throw new Error(`KHR_xmp_json_ld: Missing context for term, "${e}".`)}}function pt(e){return JSON.parse(JSON.stringify(e))}gt.EXTENSION_NAME="KHR_xmp_json_ld";const xt="KHR_xmp_json_ld";class Tt extends _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.Extension{constructor(...e){super(...e),this.extensionName=xt}createPacket(){return new gt(this.document.getGraph())}listPackets(){return Array.from(this.properties)}read(e){var t;const s=null==(t=e.jsonDoc.json.extensions)?void 0:t[xt];if(!s||!s.packets)return this;const r=e.jsonDoc.json,n=this.document.getRoot(),o=s.packets.map(e=>this.createPacket().fromJSONLD(e)),i=[[r.asset],r.scenes,r.nodes,r.meshes,r.materials,r.images,r.animations],a=[[n],n.listScenes(),n.listNodes(),n.listMeshes(),n.listMaterials(),n.listTextures(),n.listAnimations()];for(let e=0;e<i.length;e++){const t=i[e]||[];for(let s=0;s<t.length;s++){const r=t[s];r.extensions&&r.extensions[xt]&&a[e][s].setExtension(xt,o[r.extensions[xt].packet])}}return this}write(e){const{json:s}=e.jsonDoc,r=[];for(const n of this.properties){r.push(n.toJSONLD());for(const o of n.listParents()){let n;switch(o.propertyType){case _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.ROOT:n=s.asset;break;case _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.SCENE:n=s.scenes[e.sceneIndexMap.get(o)];break;case _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.NODE:n=s.nodes[e.nodeIndexMap.get(o)];break;case _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.MESH:n=s.meshes[e.meshIndexMap.get(o)];break;case _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.MATERIAL:n=s.materials[e.materialIndexMap.get(o)];break;case _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.TEXTURE:n=s.images[e.imageIndexMap.get(o)];break;case _gltf_transform_core__WEBPACK_IMPORTED_MODULE_1__.PropertyType.ANIMATION:n=s.animations[e.animationIndexMap.get(o)];break;default:n=null,this.document.getLogger().warn(`[${xt}]: Unsupported parent property, "${o.propertyType}"`)}n&&(n.extensions=n.extensions||{},n.extensions[xt]={packet:r.length-1})}}return r.length>0&&(s.extensions=s.extensions||{},s.extensions[xt]={packets:r}),this}}Tt.EXTENSION_NAME=xt;const dt=[ne,ce,pe,de,Ne,Ce,Pe,je,Ke,$e,Ze,rt,ot,ct,ht,Tt],mt=[I,L,P,...dt];
//# sourceMappingURL=extensions.modern.js.map


/***/ }),

/***/ "./node_modules/@gltf-transform/functions/dist/functions.modern.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@gltf-transform/functions/dist/functions.modern.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bounds": () => (/* reexport safe */ _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.bounds),
/* harmony export */   "QUANTIZE_DEFAULTS": () => (/* binding */ Rt),
/* harmony export */   "TEXTURE_RESIZE_DEFAULTS": () => (/* binding */ Yt),
/* harmony export */   "TextureResizeFilter": () => (/* binding */ Jt),
/* harmony export */   "center": () => (/* binding */ F),
/* harmony export */   "colorspace": () => (/* binding */ G),
/* harmony export */   "dedup": () => (/* binding */ B),
/* harmony export */   "dequantize": () => (/* binding */ W),
/* harmony export */   "inspect": () => (/* binding */ X),
/* harmony export */   "instance": () => (/* binding */ rt),
/* harmony export */   "metalRough": () => (/* binding */ ct),
/* harmony export */   "normals": () => (/* binding */ pt),
/* harmony export */   "partition": () => (/* binding */ yt),
/* harmony export */   "prune": () => (/* binding */ ht),
/* harmony export */   "quantize": () => (/* binding */ Nt),
/* harmony export */   "reorder": () => (/* binding */ Ut),
/* harmony export */   "resample": () => (/* binding */ Ft),
/* harmony export */   "sequence": () => (/* binding */ Wt),
/* harmony export */   "tangents": () => (/* binding */ jt),
/* harmony export */   "textureResize": () => (/* binding */ Qt),
/* harmony export */   "unweld": () => (/* binding */ gt),
/* harmony export */   "weld": () => (/* binding */ ee)
/* harmony export */ });
/* harmony import */ var _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @gltf-transform/core */ "./node_modules/@gltf-transform/core/dist/core.modern.js");
/* harmony import */ var ndarray_pixels__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ndarray-pixels */ "./node_modules/ndarray-pixels/dist/ndarray-pixels-browser.modern.js");
/* harmony import */ var _gltf_transform_extensions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @gltf-transform/extensions */ "./node_modules/@gltf-transform/extensions/dist/extensions.modern.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gl-matrix/vec3 */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gl-matrix/mat4 */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ndarray */ "./node_modules/ndarray/ndarray.js");
/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ndarray__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ndarray_lanczos__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ndarray-lanczos */ "./node_modules/ndarray-lanczos/dist/ndarray-lanczos.modern.js");
function L(){return(L=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&(t[s]=n[s])}return t}).apply(this,arguments)}function $(t,e){return Object.defineProperty(e,"name",{value:t}),e}async function v(t,e,n){if(!t)return null;const s=t.getImage();if(!s)return null;const r=await (0,ndarray_pixels__WEBPACK_IMPORTED_MODULE_2__.getPixels)(s,t.getMimeType());for(let t=0;t<r.shape[0];++t)for(let e=0;e<r.shape[1];++e)n(r,t,e);const o=await (0,ndarray_pixels__WEBPACK_IMPORTED_MODULE_2__.savePixels)(r,"image/png");return e.setImage(o).setMimeType("image/png")}class _{constructor(){this._map=new Map}get size(){return this._map.size}has(t){return this._map.has(t)}add(t,e){let n=this._map.get(t);return n||(n=new Set,this._map.set(t,n)),n.add(e),this}get(t){return this._map.get(t)||new Set}keys(){return this._map.keys()}}const k={pivot:"center"};function F(t=k){const n=L({},k,t);return $("center",t=>{const s=t.getLogger(),r=t.getRoot(),o=r.listAnimations().length>0||r.listSkins().length>0;t.getRoot().listScenes().forEach((i,a)=>{let c;if(s.debug(`center: Scene ${a+1} / ${r.listScenes().length}.`),"string"==typeof n.pivot){const t=(0,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.bounds)(i);c=[(t.max[0]-t.min[0])/2+t.min[0],(t.max[1]-t.min[1])/2+t.min[1],(t.max[2]-t.min[2])/2+t.min[2]],"above"===n.pivot&&(c[1]=t.max[1]),"below"===n.pivot&&(c[1]=t.min[1])}else c=n.pivot;s.debug(`center: Pivot "${c.join(", ")}".`);const l=[-1*c[0],-1*c[1],-1*c[2]];if(o){s.debug("center: Model contains animation or skin. Adding a wrapper node.");const e=t.createNode("Pivot").setTranslation(l);i.listChildren().forEach(t=>e.addChild(t)),i.addChild(e)}else s.debug("center: Skipping wrapper, offsetting all root nodes."),i.listChildren().forEach(t=>{const e=t.getTranslation();t.setTranslation([e[0]+l[0],e[1]+l[1],e[2]+l[2]])})}),s.debug("center: Complete.")})}const q="colorspace";function G(t){return $(q,e=>{const n=e.getLogger();if("linear"===t.inputEncoding)return void n.info(`${q}: Vertex colors already linear. Skipping conversion.`);if("sRGB"!==t.inputEncoding)return void n.error(`${q}: Unknown input encoding "${t.inputEncoding}" – should be "sRGB" or "linear". Skipping conversion.`);const s=new Set;function r(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function o(t){const e=[0,0,0];let n;for(let o=0;n=t.getAttribute(`COLOR_${o}`);o++)if(!s.has(n)){for(let t=0;t<n.getCount();t++)n.getElement(t,e),e[0]=r(e[0]),e[1]=r(e[1]),e[2]=r(e[2]),n.setElement(t,e);s.add(n)}}e.getRoot().listMeshes().forEach(t=>t.listPrimitives().forEach(o)),n.debug(`${q}: Complete.`)})}const U={propertyTypes:[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.ACCESSOR,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.MESH,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.TEXTURE,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.MATERIAL]},B=function(t=U){const e=L({},U,t),o=new Set(e.propertyTypes);for(const t of e.propertyTypes)if(!U.propertyTypes.includes(t))throw new Error(`dedup: Unsupported deduplication on type "${t}".`);return $("dedup",t=>{const e=t.getLogger();o.has(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.ACCESSOR)&&function(t,e){const n=new Set,r=new Set,o=new Set,i=new Set,a=e.getRoot().listMeshes();a.forEach(t=>{t.listPrimitives().forEach(t=>{t.listAttributes().forEach(t=>r.add(t));const e=t.getIndices();e&&n.add(e)})});for(const t of e.getRoot().listAnimations())for(const e of t.listSamplers()){const t=e.getInput(),n=e.getOutput();t&&o.add(t),n&&i.add(n)}function c(t){const e=new Map;for(let n=0;n<t.length;n++){const r=t[n],o=_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.BufferUtils.toView(r.getArray());if(!e.has(r))for(let n=0;n<t.length;n++){const i=t[n];r!==i&&(e.has(i)||r.getType()===i.getType()&&r.getComponentType()===i.getComponentType()&&r.getCount()===i.getCount()&&r.getNormalized()===i.getNormalized()&&_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.BufferUtils.equals(o,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.BufferUtils.toView(i.getArray()))&&e.set(i,r))}}return e}const l=c(Array.from(n));t.debug(`dedup: Found ${l.size} duplicates among ${n.size} indices.`);const g=c(Array.from(r));t.debug(`dedup: Found ${g.size} duplicates among ${r.size} attributes.`);const u=c(Array.from(o)),f=c(Array.from(i));t.debug(`dedup: Found ${u.size+f.size} duplicates among ${o.size+i.size} animation accessors.`),a.forEach(t=>{t.listPrimitives().forEach(t=>{t.listAttributes().forEach(e=>{g.has(e)&&t.swap(e,g.get(e))});const e=t.getIndices();e&&l.has(e)&&t.swap(e,l.get(e))})}),Array.from(l.keys()).forEach(t=>t.dispose()),Array.from(g.keys()).forEach(t=>t.dispose());for(const t of e.getRoot().listAnimations())for(const e of t.listSamplers()){const t=e.getInput(),n=e.getOutput();t&&u.has(t)&&e.swap(t,u.get(t)),n&&f.has(n)&&e.swap(n,f.get(n))}Array.from(u.keys()).forEach(t=>t.dispose()),Array.from(f.keys()).forEach(t=>t.dispose())}(e,t),o.has(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.MESH)&&function(t,e){const s=e.getRoot(),r=new Map;s.listAccessors().forEach((t,e)=>r.set(t,e)),s.listMaterials().forEach((t,e)=>r.set(t,e));const o=s.listMeshes().length,i=new Map;for(const t of s.listMeshes()){const e=[];for(const n of t.listPrimitives())e.push(V(n,r));const s=e.join(";");if(i.has(s)){const e=i.get(s);t.listParents().forEach(s=>{s.propertyType!==_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.ROOT&&s.swap(t,e)}),t.dispose()}else i.set(s,t)}t.debug(`dedup: Found ${o-i.size} duplicates among ${o} meshes.`)}(e,t),o.has(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.TEXTURE)&&function(t,e){const n=e.getRoot(),o=n.listTextures(),i=new Map;for(let t=0;t<o.length;t++){const e=o[t],n=e.getImage();if(!i.has(e))for(let t=0;t<o.length;t++){const r=o[t],a=r.getImage();if(e===r)continue;if(i.has(r))continue;if(e.getMimeType()!==r.getMimeType())continue;const c=e.getSize(),l=r.getSize();c&&l&&c[0]===l[0]&&c[1]===l[1]&&n&&a&&_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.BufferUtils.equals(n,a)&&i.set(r,e)}}t.debug(`dedup: Found ${i.size} duplicates among ${n.listTextures().length} textures.`),Array.from(i.entries()).forEach(([t,e])=>{t.listParents().forEach(n=>{n instanceof _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Root||n.swap(t,e)}),t.dispose()})}(e,t),o.has(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.MATERIAL)&&function(t,e){const n=e.getRoot(),s=n.listMaterials(),o=new Map;for(let t=0;t<s.length;t++){const e=s[t];if(!o.has(e))for(let t=0;t<s.length;t++){const n=s[t];e!==n&&(o.has(n)||e.equals(n)&&o.set(n,e))}}t.debug(`dedup: Found ${o.size} duplicates among ${n.listMaterials().length} materials.`),Array.from(o.entries()).forEach(([t,e])=>{t.listParents().forEach(n=>{n instanceof _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Root||n.swap(t,e)}),t.dispose()})}(e,t),e.debug("dedup: Complete.")})};function V(e,n){const s=[];for(const t of e.listSemantics()){const r=e.getAttribute(t);s.push(t+":"+n.get(r))}if(e instanceof _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Primitive){const t=e.getIndices();t&&s.push("indices:"+n.get(t));const r=e.getMaterial();r&&s.push("material:"+n.get(r)),s.push("mode:"+e.getMode());for(const t of e.listTargets())s.push("target:"+V(t,n))}return s.join(",")}const H={pattern:/^((?!JOINTS_).)*$/};function W(t=H){const e=L({},H,t);return $("dequantize",t=>{const n=t.getLogger();for(const n of t.getRoot().listMeshes())for(const t of n.listPrimitives())D(t,e);t.createExtension(_gltf_transform_extensions__WEBPACK_IMPORTED_MODULE_3__.MeshQuantization).dispose(),n.debug("dequantize: Complete.")})}function D(t,e){for(const n of t.listSemantics())j(n,t.getAttribute(n),e);for(const n of t.listTargets())for(const t of n.listSemantics())j(t,n.getAttribute(t),e)}function j(t,e,n){if(!e.getArray())return;if(!n.pattern.test(t))return;if(e.getComponentSize()>=4)return;const s=e.getArray(),r=new Float32Array(s.length);for(let t=0,n=e.getCount(),o=[];t<n;t++)o=e.getElement(t,o),e.setArray(r).setElement(t,o).setArray(s);e.setArray(r).setNormalized(!1)}function X(t){return{scenes:K(t),meshes:Z(t),materials:J(t),textures:Y(t),animations:Q(t)}}function K(t){return{properties:t.getRoot().listScenes().map(t=>{const n=t.listChildren()[0],s=(0,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.bounds)(t);return{name:t.getName(),rootName:n?n.getName():"",bboxMin:et(s.min),bboxMax:et(s.max)}})}}function Z(e){return{properties:e.getRoot().listMeshes().map(e=>{const n=e.listParents().filter(t=>"Root"!==t.propertyType).length;let s=0,r=0;const o=new Set,i=new Set,a=new Set;e.listPrimitives().forEach(e=>{for(const t of e.listSemantics()){const n=e.getAttribute(t);o.add(t+":"+nt(n.getArray())),a.add(n)}for(const t of e.listTargets())t.listAttributes().forEach(t=>a.add(t));const n=e.getIndices();n&&(i.add(nt(n.getArray())),a.add(n)),r+=e.listAttributes()[0].getCount(),s+=function(e){const n=e.getIndices(),s=e.getAttribute("POSITION");switch(e.getMode()){case _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Primitive.Mode.POINTS:return s.getCount();case _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Primitive.Mode.LINES:return n?n.getCount()/2:s.getCount()/2;case _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Primitive.Mode.LINE_LOOP:return s.getCount();case _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Primitive.Mode.LINE_STRIP:return s.getCount()-1;case _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Primitive.Mode.TRIANGLES:return n?n.getCount()/3:s.getCount()/3;case _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Primitive.Mode.TRIANGLE_STRIP:case _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Primitive.Mode.TRIANGLE_FAN:return s.getCount()-2;default:throw new Error("Unexpected mode: "+e.getMode())}}(e)});let c=0;Array.from(a).forEach(t=>c+=t.getArray().byteLength);const l=e.listPrimitives().map(t=>tt[t.getMode()]);return{name:e.getName(),mode:Array.from(new Set(l)),primitives:e.listPrimitives().length,glPrimitives:s,vertices:r,indices:Array.from(i).sort(),attributes:Array.from(o).sort(),instances:n,size:c}})}}function J(t){return{properties:t.getRoot().listMaterials().map(e=>{const n=e.listParents().filter(t=>"Root"!==t.propertyType).length,s=new Set(e.listExtensions()),r=t.getGraph().listEdges().filter(t=>{const n=t.getChild(),r=t.getParent();return n instanceof _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Texture&&r===e||!!(n instanceof _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Texture&&r instanceof _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionProperty&&s.has(r))}).map(t=>t.getName());return{name:e.getName(),instances:n,textures:r,alphaMode:e.getAlphaMode(),doubleSided:e.getDoubleSided()}})}}function Y(t){return{properties:t.getRoot().listTextures().map(e=>{const n=e.listParents().filter(t=>"Root"!==t.propertyType).length,s=t.getGraph().listParentEdges(e).map(t=>t.getName()).filter(t=>"texture"!==t),r=_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.ImageUtils.getSize(e.getImage(),e.getMimeType());return{name:e.getName(),uri:e.getURI(),slots:Array.from(new Set(s)),instances:n,mimeType:e.getMimeType(),resolution:r?r.join("x"):"",size:e.getImage().byteLength,gpuSize:_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.ImageUtils.getMemSize(e.getImage(),e.getMimeType())}})}}function Q(t){return{properties:t.getRoot().listAnimations().map(t=>{let e=Infinity,n=-Infinity;t.listSamplers().forEach(t=>{const s=t.getInput();s&&(e=Math.min(e,s.getMin([])[0]),n=Math.max(n,s.getMax([])[0]))});let s=0,r=0;const o=new Set;return t.listSamplers().forEach(t=>{const e=t.getInput(),n=t.getOutput();e&&(r+=e.getCount(),o.add(e),n&&o.add(n))}),Array.from(o).forEach(t=>{s+=t.getArray().byteLength}),{name:t.getName(),channels:t.listChannels().length,samplers:t.listSamplers().length,duration:Math.round(1e3*(n-e))/1e3,keyframes:r,size:s}})}}const tt=["POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN"];function et(t){for(let e=0;e<t.length;e++)t[e].toFixed&&(t[e]=Number(t[e].toFixed(5)));return t}function nt(t){return t.constructor.name.replace("Array","").toLowerCase()}const st={};function rt(t=st){return L({},st,t),$("instance",t=>{const e=t.getLogger(),n=t.getRoot(),s=t.createExtension(_gltf_transform_extensions__WEBPACK_IMPORTED_MODULE_3__.MeshGPUInstancing);if(n.listAnimations().length)throw new Error("instance: Instancing is not currently supported for animated models.");let r=0,o=0;for(const i of n.listScenes()){const n=new Map;i.traverse(t=>{const e=t.getMesh();e&&n.set(e,(n.get(e)||new Set).add(t))});const a=[];for(const l of Array.from(n.keys())){const g=Array.from(n.get(l));if(g.length<2)continue;if(g.some(t=>t.getSkin()))continue;const u=it(t,s,l,g.length),f=u.getAttribute("TRANSLATION"),p=u.getAttribute("ROTATION"),m=u.getAttribute("SCALE"),d=t.createNode().setMesh(l).setExtension("EXT_mesh_gpu_instancing",u);i.addChild(d);let h=!1,A=!1,y=!1;for(let t=0;t<g.length;t++){let e,n,s;const r=g[t];f.setElement(t,e=r.getWorldTranslation()),p.setElement(t,n=r.getWorldRotation()),m.setElement(t,s=r.getWorldScale()),_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.MathUtils.eq(e,[0,0,0])||(h=!0),_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.MathUtils.eq(n,[0,0,0,1])||(A=!0),_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.MathUtils.eq(s,[1,1,1])||(y=!0),r.setMesh(null),a.push(r)}h||f.dispose(),A||p.dispose(),y||m.dispose(),ot(a,e),r++,o+=g.length}}r>0?e.info(`instance: Created ${r} batches, with ${o} total instances.`):(e.info("instance: No meshes with multiple parent nodes were found."),s.dispose()),e.debug("instance: Complete.")})}function ot(t,e){let n,s=0;for(;n=t.pop();){if(n.listChildren().length||n.getCamera()||n.getMesh()||n.getSkin()||n.listExtensions().length)continue;const e=n.getParent();e instanceof _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Node&&t.push(e),n.dispose(),s++}e.debug(`instance: Removed ${s} unused nodes.`)}function it(t,e,n,s){const r=n.listPrimitives()[0].getAttribute("POSITION").getBuffer(),o=t.createAccessor().setType("VEC3").setArray(new Float32Array(3*s)).setBuffer(r),i=t.createAccessor().setType("VEC4").setArray(new Float32Array(4*s)).setBuffer(r),a=t.createAccessor().setType("VEC3").setArray(new Float32Array(3*s)).setBuffer(r);return e.createInstancedMesh().setAttribute("TRANSLATION",o).setAttribute("ROTATION",i).setAttribute("SCALE",a)}const at={};function ct(t=at){return L({},at,t),$("metalRough",async t=>{const e=t.getLogger();if(!t.getRoot().listExtensionsUsed().map(t=>t.extensionName).includes("KHR_materials_pbrSpecularGlossiness"))return void e.warn("metalRough: KHR_materials_pbrSpecularGlossiness not found on document.");const n=t.createExtension(_gltf_transform_extensions__WEBPACK_IMPORTED_MODULE_3__.MaterialsIOR),s=t.createExtension(_gltf_transform_extensions__WEBPACK_IMPORTED_MODULE_3__.MaterialsSpecular),r=t.createExtension(_gltf_transform_extensions__WEBPACK_IMPORTED_MODULE_3__.MaterialsPBRSpecularGlossiness),o=new Set;for(const e of t.getRoot().listMaterials()){const r=e.getExtension("KHR_materials_pbrSpecularGlossiness");if(!r)continue;const i=s.createSpecular().setSpecularFactor(1).setSpecularColorFactor(r.getSpecularFactor());o.add(r.getSpecularGlossinessTexture()),o.add(e.getBaseColorTexture()),o.add(e.getMetallicRoughnessTexture()),e.setBaseColorFactor(r.getDiffuseFactor()).setMetallicFactor(0).setRoughnessFactor(1).setExtension("KHR_materials_ior",n.createIOR().setIOR(1e3)).setExtension("KHR_materials_specular",i);const a=r.getDiffuseTexture();a&&(e.setBaseColorTexture(a),e.getBaseColorTextureInfo().copy(r.getDiffuseTextureInfo()));const c=r.getSpecularGlossinessTexture();if(c){const n=r.getSpecularGlossinessTextureInfo(),s=t.createTexture();await v(c,s,(t,e,n)=>{t.set(e,n,3,255)}),i.setSpecularTexture(s),i.setSpecularColorTexture(s),i.getSpecularTextureInfo().copy(n),i.getSpecularColorTextureInfo().copy(n);const o=r.getGlossinessFactor(),a=t.createTexture();await v(c,a,(t,e,n)=>{const s=255-Math.round(t.get(e,n,3)*o);t.set(e,n,0,0),t.set(e,n,1,s),t.set(e,n,2,0),t.set(e,n,3,255)}),e.setMetallicRoughnessTexture(a),e.getMetallicRoughnessTextureInfo().copy(n)}else i.setSpecularColorFactor(r.getSpecularFactor()),e.setRoughnessFactor(1-r.getGlossinessFactor());e.setExtension("KHR_materials_pbrSpecularGlossiness",null)}r.dispose();for(const t of o)t&&1===t.listParents().length&&t.dispose();e.debug("metalRough: Complete.")})}const lt={};function gt(t=lt){return L({},lt,t),$("unweld",t=>{const e=t.getLogger(),n=new Map;for(const s of t.getRoot().listMeshes())for(const t of s.listPrimitives()){const s=t.getIndices();if(s){for(const r of t.listAttributes())t.swap(r,ut(r,s,e,n)),1===r.listParents().length&&r.dispose();for(const r of t.listTargets())for(const t of r.listAttributes())r.swap(t,ut(t,s,e,n)),1===t.listParents().length&&t.dispose();t.setIndices(null),1===s.listParents().length&&s.dispose()}}e.debug("unweld: Complete.")})}function ut(t,e,n,s){if(s.has(t)&&s.get(t).has(e))return n.debug(`unweld: Cache hit for reused attribute, "${t.getName()}".`),s.get(t).get(e);const r=t.clone(),o=t.getArray().constructor;r.setArray(new o(e.getCount()*t.getElementSize()));const i=[];for(let n=0;n<e.getCount();n++)r.setElement(n,t.getElement(e.getScalar(n),i));return s.has(t)||s.set(t,new Map),s.get(t).set(e,r),r}const ft={overwrite:!1};function pt(t=ft){const e=L({},ft,t);return $("normals",async t=>{const n=t.getLogger();let s=0;await t.transform(gt());for(const r of t.getRoot().listMeshes())for(const o of r.listPrimitives()){const r=o.getAttribute("POSITION");let i=o.getAttribute("NORMAL");if(e.overwrite&&i)i.dispose();else if(i){n.debug("normals: Skipping primitive: NORMAL found.");continue}i=t.createAccessor().setArray(new Float32Array(3*r.getCount())).setType("VEC3");const a=[0,0,0],c=[0,0,0],l=[0,0,0];for(let t=0;t<r.getCount();t+=3){r.getElement(t+0,a),r.getElement(t+1,c),r.getElement(t+2,l);const e=mt(a,c,l);i.setElement(t+0,e),i.setElement(t+1,e),i.setElement(t+2,e)}o.setAttribute("NORMAL",i),s++}s?n.debug("normals: Complete."):n.warn("normals: No qualifying primitives found. See debug output.")})}function mt(t,e,n){const s=[e[0]-t[0],e[1]-t[1],e[2]-t[2]],r=[n[0]-t[0],n[1]-t[1],n[2]-t[2]];return (0,gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_4__.normalize)([0,0,0],[s[1]*r[2]-s[2]*r[1],s[2]*r[0]-s[0]*r[2],s[0]*r[1]-s[1]*r[0]])}const dt={propertyTypes:[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.NODE,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.SKIN,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.MESH,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.CAMERA,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.PRIMITIVE,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.PRIMITIVE_TARGET,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.ANIMATION,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.MATERIAL,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.TEXTURE,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.ACCESSOR,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.BUFFER]},ht=function(t=dt){const e=L({},dt,t).propertyTypes;return $("prune",t=>{const s=t.getLogger(),o=t.getRoot(),i=t.getGraph(),a={};if(e.includes(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.NODE)&&o.listNodes().forEach(c),e.includes(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.SKIN)&&o.listSkins().forEach(c),e.includes(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.MESH)&&o.listMeshes().forEach(c),e.includes(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.CAMERA)&&o.listCameras().forEach(c),e.includes(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.PRIMITIVE)&&l(i,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.PRIMITIVE),e.includes(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.PRIMITIVE_TARGET)&&l(i,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.PRIMITIVE_TARGET),e.includes(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.ANIMATION))for(const t of o.listAnimations()){for(const e of t.listChannels())e.getTargetNode()||(e.dispose(),u(e));if(t.listChannels().length)t.listSamplers().forEach(c);else{const e=t.listSamplers();c(t),e.forEach(c)}}if(e.includes(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.MATERIAL)&&o.listMaterials().forEach(c),e.includes(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.TEXTURE)&&o.listTextures().forEach(c),e.includes(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.ACCESSOR)&&o.listAccessors().forEach(c),e.includes(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.BUFFER)&&o.listBuffers().forEach(c),Object.keys(a).length){const t=Object.keys(a).map(t=>`${t} (${a[t]})`).join(", ");s.info(`prune: Removed types... ${t}`)}else s.info("prune: No unused properties found.");function c(t){t.listParents().filter(t=>!(t instanceof _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Root||t instanceof _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.AnimationChannel)).length||(t.dispose(),u(t))}function l(t,e){t.listEdges().map(t=>t.getParent()).filter(t=>t.propertyType===e).forEach(c)}function u(t){a[t.propertyType]=a[t.propertyType]||0,a[t.propertyType]++}s.debug("prune: Complete.")})},At={animations:!0,meshes:!0},yt=(t=At)=>{const e=L({},At,t);return $("partition",async t=>{const s=t.getLogger();!1!==e.meshes&&function(t,e,n){const s=new Set(t.getRoot().listBuffers().map(t=>t.getURI()));t.getRoot().listMeshes().forEach((r,o)=>{if(Array.isArray(n.meshes)&&!n.meshes.includes(r.getName()))return void e.debug(`partition: Skipping mesh #${o} with name "${r.getName()}".`);e.debug(`partition: Creating buffer for mesh "${r.getName()}".`);const i=t.createBuffer(r.getName()).setURI(Et(r.getName()||"mesh",s));r.listPrimitives().forEach(t=>{const e=t.getIndices();e&&e.setBuffer(i),t.listAttributes().forEach(t=>t.setBuffer(i)),t.listTargets().forEach(t=>{t.listAttributes().forEach(t=>t.setBuffer(i))})})})}(t,s,e),!1!==e.animations&&function(t,e,n){const s=new Set(t.getRoot().listBuffers().map(t=>t.getURI()));t.getRoot().listAnimations().forEach((r,o)=>{if(Array.isArray(n.animations)&&!n.animations.includes(r.getName()))return void e.debug(`partition: Skipping animation #${o} with name "${r.getName()}".`);e.debug(`partition: Creating buffer for animation "${r.getName()}".`);const i=t.createBuffer(r.getName()).setURI(Et(r.getName()||"animation",s));r.listSamplers().forEach(t=>{const e=t.getInput(),n=t.getOutput();e&&e.setBuffer(i),n&&n.setBuffer(i)})})}(t,s,e),e.meshes||e.animations||s.warn("partition: Select animations or meshes to create a partition."),await t.transform(ht({propertyTypes:[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.BUFFER]})),s.debug("partition: Complete.")})};function Et(t,e){let n=`${t}.bin`,s=1;for(;e.has(n);)n=`${t}_${s++}.bin`;return n}const Tt=[Int8Array,Int16Array,Int32Array],{TRANSLATION:St,ROTATION:It,SCALE:bt,WEIGHTS:wt}=_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.AnimationChannel.TargetPath,Mt=[St,It,bt],Rt={pattern:/.*/,quantizationVolume:"mesh",quantizePosition:14,quantizeNormal:10,quantizeTexcoord:12,quantizeColor:8,quantizeWeight:8,quantizeGeneric:12},Nt=(t=Rt)=>{const e=L({},Rt,t);return $("quantize",async t=>{const s=t.getLogger(),r=t.getRoot();let o;t.createExtension(_gltf_transform_extensions__WEBPACK_IMPORTED_MODULE_3__.MeshQuantization).setRequired(!0),"scene"===e.quantizationVolume&&(o=Ot(function(t){const e=t[0];for(const n of t)(0,gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_4__.min)(e.min,e.min,n.min),(0,gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_4__.max)(e.max,e.max,n.max);return e}(r.listMeshes().map($t))));for(const n of t.getRoot().listMeshes()){"mesh"===e.quantizationVolume&&(o=Ot($t(n))),o&&e.pattern.test("POSITION")&&Pt(t,n,o);for(const s of n.listPrimitives()){Ct(t,s,o,e);for(const n of s.listTargets())Ct(t,n,o,e)}}await t.transform(ht({propertyTypes:[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.ACCESSOR,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.SKIN]}),B({propertyTypes:[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.ACCESSOR]})),s.debug("quantize: Complete.")})};function Ct(e,n,s,r){const o=e.getLogger();for(const e of n.listSemantics()){if(!r.pattern.test(e))continue;const i=n.getAttribute(e),{bits:a,ctor:c}=Lt(e,i,o,r);if(!c)continue;if(a<8||a>16)throw new Error("quantize: Requires bits = 8–16.");if(i.getComponentSize()<=a/8)continue;const l=i.clone();if("POSITION"===e){const e=s.scale,r=[];n instanceof _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Primitive?(0,gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_5__.invert)(r,_t(s)):(0,gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_5__.fromScaling)(r,[1/e,1/e,1/e]);for(let t=0,e=[0,0,0],n=l.getCount();t<n;t++)l.getElement(t,e),l.setElement(t,(0,gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_4__.transformMat4)(e,e,r))}zt(l,c,a),n.swap(i,l)}if(n.getAttribute("WEIGHTS_0")&&function(t){const e=t.getAttribute("POSITION").getCount(),n=[];for(let s=0;s<e;s++){let e,r=0,o=Infinity,i=-1,a=null,c=0;for(;e=t.getAttribute("WEIGHTS_"+c++);){e.getElement(s,n);for(let t=0;t<n.length;t++)r+=n[t],n[t]>0&&n[t]<o&&(a=e,o=n[t],i=t)}a&&1!==r&&(a.getElement(s,n),n[i]+=1-r,a.setElement(s,n))}}(n),n instanceof _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Primitive&&n.getIndices()&&n.listAttributes().length&&n.listAttributes()[0].getCount()<65535){const t=n.getIndices();t.setArray(new Uint16Array(t.getArray()))}}function Ot(t){const{min:e,max:n}=t,s=Math.max((n[0]-e[0])/2,(n[1]-e[1])/2,(n[2]-e[2])/2);return{offset:[e[0]+(n[0]-e[0])/2,e[1]+(n[1]-e[1])/2,e[2]+(n[2]-e[2])/2],scale:s}}function Pt(t,e,n){const s=_t(n);for(const r of e.listParents())if(r instanceof _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Node){const o=r.listParents().filter(t=>t instanceof _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.AnimationChannel),i=o.some(t=>Mt.includes(t.getTargetPath())),a=r.listChildren().length>0;if(r.getSkin()){r.setSkin(xt(r.getSkin(),n));continue}let c;a||i?(c=t.createNode("").setMesh(e),r.addChild(c).setMesh(null),o.filter(t=>t.getTargetPath()===wt).forEach(t=>t.setTargetNode(c))):c=r;const l=c.getMatrix();(0,gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_5__.multiply)(l,l,s),c.setMatrix(l)}}function xt(t,e){t=t.clone();const n=_t(e),s=t.getInverseBindMatrices().clone(),r=[];for(let t=0,e=s.getCount();t<e;t++)s.getElement(t,r),(0,gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_5__.multiply)(r,r,n),s.setElement(t,r);return t.setInverseBindMatrices(s)}function zt(t,e,n){const s=new e(t.getArray().length),r=Tt.includes(e)?1:0,o=n-r,i=8*e.BYTES_PER_ELEMENT-r,a=Math.pow(2,o)-1,c=i-o,l=2*o-i;for(let e=0,n=0,r=[];e<t.getCount();e++){t.getElement(e,r);for(let t=0;t<r.length;t++){let e=Math.round(Math.abs(r[t])*a);e=e<<c|e>>l,s[n++]=e*Math.sign(r[t])}}t.setArray(s).setNormalized(!0)}function Lt(t,e,n,s){const r=e.getMinNormalized([]),o=e.getMaxNormalized([]);let i,a;if("POSITION"===t)i=s.quantizePosition,a=i<=8?Int8Array:Int16Array;else if("NORMAL"===t||"TANGENT"===t)i=s.quantizeNormal,a=i<=8?Int8Array:Int16Array;else if(t.startsWith("COLOR_"))i=s.quantizeColor,a=i<=8?Uint8Array:Uint16Array;else if(t.startsWith("TEXCOORD_")){if(r.some(t=>t<0)||o.some(t=>t>1))return n.warn(`quantize: Skipping ${t}; out of [0,1] range.`),{bits:-1};i=s.quantizeTexcoord,a=i<=8?Uint8Array:Uint16Array}else{if(t.startsWith("JOINTS_"))return i=Math.max(...e.getMax([]))<=255?8:16,a=i<=8?Uint8Array:Uint16Array,e.getComponentSize()>i/8&&e.setArray(new a(e.getArray())),{bits:-1};if(t.startsWith("WEIGHTS_")){if(r.some(t=>t<0)||o.some(t=>t>1))return n.warn(`quantize: Skipping ${t}; out of [0,1] range.`),{bits:-1};i=s.quantizeWeight,a=i<=8?Uint8Array:Uint16Array}else{if(!t.startsWith("_"))throw new Error(`quantize: Unexpected semantic, "${t}".`);if(r.some(t=>t<-1)||o.some(t=>t>1))return n.warn(`quantize: Skipping ${t}; out of [-1,1] range.`),{bits:-1};i=s.quantizeGeneric,a=a=r.some(t=>t<0)?i<=8?Int8Array:Int16Array:i<=8?Uint8Array:Uint16Array}}return{bits:i,ctor:a}}function $t(t){const e=[],n=[];for(const s of t.listPrimitives()){const t=s.getAttribute("POSITION");t&&e.push(t);for(const t of s.listTargets()){const e=t.getAttribute("POSITION");e&&n.push(e)}}if(0===e.length)throw new Error('quantize: Missing "POSITION" attribute.');const s=vt(e,3);if(n.length>0){const{min:t,max:e}=vt(n,3);(0,gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_4__.min)(s.min,s.min,(0,gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_4__.min)(t,(0,gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_4__.scale)(t,t,2),[0,0,0])),(0,gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_4__.max)(s.max,s.max,(0,gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_4__.max)(e,(0,gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_4__.scale)(e,e,2),[0,0,0]))}return s}function vt(t,e){const n=new Array(e).fill(Infinity),s=new Array(e).fill(-Infinity),r=[],o=[];for(const i of t){i.getMinNormalized(r),i.getMaxNormalized(o);for(let t=0;t<e;t++)n[t]=Math.min(n[t],r[t]),s[t]=Math.max(s[t],o[t])}return{min:n,max:s}}function _t(t){return (0,gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_5__.fromRotationTranslationScale)([],[0,0,0,1],t.offset,[t.scale,t.scale,t.scale])}const kt={tolerance:1e-4},Ft=(t=kt)=>{const e=L({},kt,t);return $("resample",(t,n)=>{const s=new Set,o=t.getRoot().listAccessors().length,i=t.getLogger();let a=!1;for(const n of t.getRoot().listAnimations()){const t=new Set;for(const e of n.listChannels())e.getSampler()&&"weights"===e.getTargetPath()&&t.add(e.getSampler());for(const r of n.listSamplers())t.has(r)?a=!0:"STEP"!==r.getInterpolation()&&"LINEAR"!==r.getInterpolation()||(s.add(r.getInput()),s.add(r.getOutput()),qt(r,e))}for(const t of Array.from(s.values()))t.listParents().some(t=>!(t instanceof _gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Root))||t.dispose();t.getRoot().listAccessors().length>o&&!function(t,e,n){return!!t&&t.stack.lastIndexOf("resample")<t.stack.lastIndexOf("dedup")}(n)&&i.warn('resample: Resampling required copying accessors, some of which may be duplicates. Consider using "dedup" to consolidate any duplicates.'),a&&i.warn("resample: Skipped optimizing morph target keyframes, not yet supported."),i.debug("resample: Complete.")})};function qt(t,e){const n=t.getInput().clone(),s=t.getOutput().clone(),r=e.tolerance,o=n.getCount()-1,i=[];let a=1;for(let e=1;e<o;++e){const o=n.getScalar(e),l=n.getScalar(e-1),g=n.getScalar(e+1),u=(o-l)/(g-l);let f=!1;if(o!==g&&(1!==e||o!==n.getScalar(0)))for(let n=0;n<s.getElementSize();n++){const o=s.getElement(e,i)[n],a=s.getElement(e-1,i)[n],l=s.getElement(e+1,i)[n];if("LINEAR"===t.getInterpolation()){if(Math.abs(o-(a*(1-(c=u))+l*c))>r){f=!0;break}}else if("STEP"===t.getInterpolation()&&(o!==a||o!==l)){f=!0;break}}f&&(e!==a&&(n.setScalar(a,n.getScalar(e)),s.setElement(a,s.getElement(e,i))),a++)}var c;o>0&&(n.setScalar(a,n.getScalar(o)),s.setElement(a,s.getElement(o,i)),a++),a!==n.getCount()?(n.setArray(n.getArray().slice(0,a)),s.setArray(s.getArray().slice(0,a*s.getElementSize())),t.setInput(n),t.setOutput(s)):(n.dispose(),s.dispose())}const Gt={target:"size"};function Ut(e=Gt){const s=L({},Gt,e),r=s.encoder;return $("reorder",async e=>{const o=e.getLogger();await r.ready;const i=function(t){const e=new _,n=new Map,s=new _;for(const r of t.getRoot().listMeshes())for(const t of r.listPrimitives()){const r=t.getIndices();if(r){n.set(r,t.getMode());for(const n of Vt(t))e.add(r,n),s.add(n,t)}}return{indicesToAttributes:e,indicesToMode:n,attributesToPrimitives:s}}(e);for(const e of i.indicesToAttributes.keys()){const n=e.clone();let o=n.getArray().slice();o instanceof Uint32Array||(o=new Uint32Array(o));const[a,c]=r.reorderMesh(o,i.indicesToMode.get(e)===_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Primitive.Mode.TRIANGLES,"size"===s.target);n.setArray(c<=65534?new Uint16Array(o):o);for(const t of i.indicesToAttributes.get(e)){const s=t.clone();Bt(s,a,c);for(const r of i.attributesToPrimitives.get(t))if(r.getIndices()===e&&r.swap(e,n),r.getIndices()===n){r.swap(t,s);for(const e of r.listTargets())e.swap(t,s)}}}await e.transform(ht({propertyTypes:[_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.PropertyType.ACCESSOR]})),i.indicesToAttributes.size?o.debug("reorder: Complete."):o.warn("reorder: No qualifying primitives found; may need to weld first.")})}function Bt(t,e,n){const s=t.getElementSize(),r=t.getCount(),o=t.getArray(),i=o.slice(0,n*s);for(let t=0;t<r;t++)for(let n=0;n<s;n++)i[e[t]*s+n]=o[t*s+n];t.setArray(i)}function Vt(t){const e=[];for(const n of t.listAttributes())e.push(n);for(const n of t.listTargets())for(const t of n.listAttributes())e.push(t);return Array.from(new Set(e))}const Ht={name:"",fps:10,pattern:/.*/,sort:!0};function Wt(t=Ht){const e=L({},Ht,t);return $("sequence",t=>{const n=t.getLogger(),s=t.getRoot(),r=e.fps,o=s.listNodes().filter(t=>t.getName().match(e.pattern));e.sort&&o.sort((t,e)=>t.getName()>e.getName()?1:-1);const i=t.createAnimation(e.name),a=s.listBuffers()[0];o.forEach((e,n)=>{let s,c;0===n?(s=[n/r,(n+1)/r],c=[1,1,1,0,0,0]):n===o.length-1?(s=[(n-1)/r,n/r],c=[0,0,0,1,1,1]):(s=[(n-1)/r,n/r,(n+1)/r],c=[0,0,0,1,1,1,0,0,0]);const l=t.createAccessor().setArray(new Float32Array(s)).setBuffer(a),p=t.createAccessor().setArray(new Float32Array(c)).setBuffer(a).setType(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Accessor.Type.VEC3),m=t.createAnimationSampler().setInterpolation(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.AnimationSampler.Interpolation.STEP).setInput(l).setOutput(p),d=t.createAnimationChannel().setTargetNode(e).setTargetPath(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.AnimationChannel.TargetPath.SCALE).setSampler(m);i.addSampler(m).addChannel(d)}),n.debug("sequence: Complete.")})}const Dt={overwrite:!1};function jt(t=Dt){if(!t.generateTangents)throw new Error('tangents: generateTangents callback required — install "mikktspace".');const e=L({},Dt,t);return $("tangents",t=>{const n=t.getLogger(),s=new Map,r=new Map;let o=0;for(const i of t.getRoot().listMeshes()){const a=i.getName(),c=i.listPrimitives();for(let i=0;i<c.length;i++){const l=c[i];if(!Kt(l,n,a,i,e.overwrite))continue;const g=Xt(l),u=l.getAttribute("POSITION").getArray(),f=l.getAttribute("NORMAL").getArray(),m=l.getAttribute(g).getArray(),d=s.get(u)||(0,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.uuid)();s.set(u,d);const h=s.get(f)||(0,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.uuid)();s.set(f,h);const A=s.get(m)||(0,_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.uuid)();s.set(m,A);const y=l.getAttribute("TANGENT");y&&2===y.listParents().length&&y.dispose();const E=`${d}|${h}|${A}`;let T=r.get(E);if(T){n.debug(`tangents: Found cache for primitive ${i} of mesh "${a}".`),l.setAttribute("TANGENT",T),o++;continue}n.debug(`tangents: Generating for primitive ${i} of mesh "${a}".`);const S=l.getAttribute("POSITION").getBuffer(),I=e.generateTangents(u instanceof Float32Array?u:new Float32Array(u),f instanceof Float32Array?f:new Float32Array(f),m instanceof Float32Array?m:new Float32Array(m));for(let t=3;t<I.length;t+=4)I[t]*=-1;T=t.createAccessor().setBuffer(S).setArray(I).setType("VEC4"),l.setAttribute("TANGENT",T),r.set(E,T),o++}}o?n.debug("tangents: Complete."):n.warn("tangents: No qualifying primitives found. See debug output.")})}function Xt(t){const e=t.getMaterial();if(!e)return"TEXCOORD_0";const n=e.getNormalTextureInfo();if(!n)return"TEXCOORD_0";const s=`TEXCOORD_${n.getTexCoord()}`;return t.getAttribute(s)?s:"TEXCOORD_0"}function Kt(e,n,s,r,o){return e.getMode()===_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Primitive.Mode.TRIANGLES&&e.getAttribute("POSITION")&&e.getAttribute("NORMAL")&&e.getAttribute("TEXCOORD_0")?e.getAttribute("TANGENT")&&!o?(n.debug(`tangents: Skipping primitive ${r} of mesh "${s}": TANGENT found.`),!1):!e.getIndices()||(n.warn(`tangents: Skipping primitive ${r} of mesh "${s}": primitives must be unwelded.`),!1):(n.debug(`tangents: Skipping primitive ${r} of mesh "${s}": primitives must have attributes=[POSITION, NORMAL, TEXCOORD_0] and mode=TRIANGLES.`),!1)}const Zt="textureResize";var Jt;!function(t){t.LANCZOS3="lanczos3",t.LANCZOS2="lanczos2"}(Jt||(Jt={}));const Yt={size:[2048,2048],filter:Jt.LANCZOS3,pattern:null};function Qt(t=Yt){const e=L({},Yt,t);return $(Zt,async t=>{const n=t.getLogger();for(const s of t.getRoot().listTextures()){const t=s.getName(),r=s.getURI();if(e.pattern&&!e.pattern.test(t)&&!e.pattern.test(r))continue;if("image/png"!==s.getMimeType()&&"image/jpeg"!==s.getMimeType()){n.warn(`Skipping unsupported texture type, "${s.getMimeType()}".`);continue}const[o,i]=e.size,[a,c]=s.getSize();if(a<=o&&c<=i){n.debug(`${Zt}: Skipping "${r||t}", within size range.`);continue}let l=a,g=c;l>o&&(g=Math.floor(g*(o/l)),l=o),g>i&&(l=Math.floor(l*(i/g)),g=i);const u=s.getImage(),f=await (0,ndarray_pixels__WEBPACK_IMPORTED_MODULE_2__.getPixels)(u,s.getMimeType()),p=ndarray__WEBPACK_IMPORTED_MODULE_1___default()(new Uint8Array(l*g*4),[l,g,4]);n.debug(`${Zt}: Resizing "${r||t}", ${f.shape} → ${p.shape}...`);try{e.filter===Jt.LANCZOS3?(0,ndarray_lanczos__WEBPACK_IMPORTED_MODULE_6__.lanczos3)(f,p):(0,ndarray_lanczos__WEBPACK_IMPORTED_MODULE_6__.lanczos2)(f,p)}catch(e){if(e instanceof Error){n.warn(`${Zt}: Failed to resize "${r||t}": "${e.message}".`);continue}throw e}s.setImage(await (0,ndarray_pixels__WEBPACK_IMPORTED_MODULE_2__.savePixels)(p,s.getMimeType()))}n.debug(`${Zt}: Complete.`)})}const te={tolerance:1e-4};function ee(e=te){const n=L({},te,e);return $("weld",e=>{const s=e.getLogger();for(const s of e.getRoot().listMeshes())for(const r of s.listPrimitives())r.getMode()!==_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Primitive.Mode.POINTS&&(0===n.tolerance?ne(e,r):se(e,r,n));s.debug("weld: Complete.")})}function ne(t,e){if(e.getIndices())return;const n=e.listAttributes()[0],s=n.getCount(),r=n.getBuffer(),o=s<=65534?new Uint16Array(s):new Uint32Array(s),i=t.createAccessor().setBuffer(r).setType(_gltf_transform_core__WEBPACK_IMPORTED_MODULE_0__.Accessor.Type.SCALAR).setArray(o);for(let t=0;t<i.getCount();t++)i.setScalar(t,t);e.setIndices(i)}function se(t,e,n){const s=Math.max(n.tolerance,Number.EPSILON),r=Math.log10(1/s),o=Math.pow(10,r),i={},a=e.getIndices(),c=a?a.getCount():e.listAttributes()[0].getCount(),l=new Map;e.listAttributes().forEach(t=>l.set(t,[])),e.listTargets().forEach(t=>{t.listAttributes().forEach(t=>l.set(t,[]))});const g=[];let u=0;for(let t=0;t<c;t++){const n=a?a.getScalar(t):t,s=[],r=[];for(const t of e.listAttributes())for(let e=0;e<t.getElementSize();e++)s.push(~~(t.getElement(n,r)[e]*o));const c=s.join("|");if(c in i)g.push(i[c]);else{for(const t of e.listAttributes())l.get(t).push(t.getElement(n,[]));for(const t of e.listTargets())for(const e of t.listAttributes())l.get(e).push(e.getElement(n,[]));i[c]=u,g.push(u),u++}}const f=e.listAttributes()[0].getCount(),p=l.get(e.getAttribute("POSITION")).length;t.getLogger().debug(`weld: ${f} → ${p} vertices.`);for(const t of e.listAttributes())oe(e,t,l.get(t)),1===t.listParents().length&&t.dispose();for(const t of e.listTargets())for(const e of t.listAttributes())oe(t,e,l.get(e)),1===e.listParents().length&&e.dispose();if(a){const t=re(a.getArray(),g.length);t.set(g),e.setIndices(a.clone().setArray(t)),1===a.listParents().length&&a.dispose()}else{const n=f<=65534?new Uint16Array(g):new Uint32Array(g);e.setIndices(t.createAccessor().setArray(n))}}function re(t,e){return new(0,t.constructor)(e)}function oe(t,e,n){const s=n.length*e.getElementSize(),r=re(e.getArray(),s),o=e.clone().setArray(r);for(let t=0;t<n.length;t++)o.setElement(t,n[t]);t.swap(e,o)}
//# sourceMappingURL=functions.modern.js.map


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = __webpack_require__.g.TYPED_ARRAY_SUPPORT !== undefined
  ? __webpack_require__.g.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}


/***/ }),

/***/ "./node_modules/cwise-compiler/compiler.js":
/*!*************************************************!*\
  !*** ./node_modules/cwise-compiler/compiler.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var createThunk = __webpack_require__(/*! ./lib/thunk.js */ "./node_modules/cwise-compiler/lib/thunk.js")

function Procedure() {
  this.argTypes = []
  this.shimArgs = []
  this.arrayArgs = []
  this.arrayBlockIndices = []
  this.scalarArgs = []
  this.offsetArgs = []
  this.offsetArgIndex = []
  this.indexArgs = []
  this.shapeArgs = []
  this.funcName = ""
  this.pre = null
  this.body = null
  this.post = null
  this.debug = false
}

function compileCwise(user_args) {
  //Create procedure
  var proc = new Procedure()
  
  //Parse blocks
  proc.pre    = user_args.pre
  proc.body   = user_args.body
  proc.post   = user_args.post

  //Parse arguments
  var proc_args = user_args.args.slice(0)
  proc.argTypes = proc_args
  for(var i=0; i<proc_args.length; ++i) {
    var arg_type = proc_args[i]
    if(arg_type === "array" || (typeof arg_type === "object" && arg_type.blockIndices)) {
      proc.argTypes[i] = "array"
      proc.arrayArgs.push(i)
      proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0)
      proc.shimArgs.push("array" + i)
      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {
        throw new Error("cwise: pre() block may not reference array args")
      }
      if(i < proc.post.args.length && proc.post.args[i].count>0) {
        throw new Error("cwise: post() block may not reference array args")
      }
    } else if(arg_type === "scalar") {
      proc.scalarArgs.push(i)
      proc.shimArgs.push("scalar" + i)
    } else if(arg_type === "index") {
      proc.indexArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array index")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array index")
      }
      if(i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array index")
      }
    } else if(arg_type === "shape") {
      proc.shapeArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {
        throw new Error("cwise: pre() block may not write to array shape")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array shape")
      }
      if(i < proc.post.args.length && proc.post.args[i].lvalue) {
        throw new Error("cwise: post() block may not write to array shape")
      }
    } else if(typeof arg_type === "object" && arg_type.offset) {
      proc.argTypes[i] = "offset"
      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })
      proc.offsetArgIndex.push(i)
    } else {
      throw new Error("cwise: Unknown argument type " + proc_args[i])
    }
  }
  
  //Make sure at least one array argument was specified
  if(proc.arrayArgs.length <= 0) {
    throw new Error("cwise: No array arguments specified")
  }
  
  //Make sure arguments are correct
  if(proc.pre.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in pre() block")
  }
  if(proc.body.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in body() block")
  }
  if(proc.post.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in post() block")
  }

  //Check debug flag
  proc.debug = !!user_args.printCode || !!user_args.debug
  
  //Retrieve name
  proc.funcName = user_args.funcName || "cwise"
  
  //Read in block size
  proc.blockSize = user_args.blockSize || 64

  return createThunk(proc)
}

module.exports = compileCwise


/***/ }),

/***/ "./node_modules/cwise-compiler/lib/compile.js":
/*!****************************************************!*\
  !*** ./node_modules/cwise-compiler/lib/compile.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var uniq = __webpack_require__(/*! uniq */ "./node_modules/uniq/uniq.js")

// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.
function innerFill(order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , has_index = proc.indexArgs.length>0
    , code = []
    , vars = []
    , idx=0, pidx=0, i, j
  for(i=0; i<dimension; ++i) { // Iteration variables
    vars.push(["i",i,"=0"].join(""))
  }
  //Compute scan deltas
  for(j=0; j<nargs; ++j) {
    for(i=0; i<dimension; ++i) {
      pidx = idx
      idx = order[i]
      if(i === 0) { // The innermost/fastest dimension's delta is simply its stride
        vars.push(["d",j,"s",i,"=t",j,"p",idx].join(""))
      } else { // For other dimensions the delta is basically the stride minus something which essentially "rewinds" the previous (more inner) dimension
        vars.push(["d",j,"s",i,"=(t",j,"p",idx,"-s",pidx,"*t",j,"p",pidx,")"].join(""))
      }
    }
  }
  if (vars.length > 0) {
    code.push("var " + vars.join(","))
  }  
  //Scan loop
  for(i=dimension-1; i>=0; --i) { // Start at largest stride and work your way inwards
    idx = order[i]
    code.push(["for(i",i,"=0;i",i,"<s",idx,";++i",i,"){"].join(""))
  }
  //Push body of inner loop
  code.push(body)
  //Advance scan pointers
  for(i=0; i<dimension; ++i) {
    pidx = idx
    idx = order[i]
    for(j=0; j<nargs; ++j) {
      code.push(["p",j,"+=d",j,"s",i].join(""))
    }
    if(has_index) {
      if(i > 0) {
        code.push(["index[",pidx,"]-=s",pidx].join(""))
      }
      code.push(["++index[",idx,"]"].join(""))
    }
    code.push("}")
  }
  return code.join("\n")
}

// Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.
function outerFill(matched, order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , blockSize = proc.blockSize
    , has_index = proc.indexArgs.length > 0
    , code = []
  for(var i=0; i<nargs; ++i) {
    code.push(["var offset",i,"=p",i].join(""))
  }
  //Generate loops for unmatched dimensions
  // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
  // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).
  for(var i=matched; i<dimension; ++i) {
    code.push(["for(var j"+i+"=SS[", order[i], "]|0;j", i, ">0;){"].join("")) // Iterate back to front
    code.push(["if(j",i,"<",blockSize,"){"].join("")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).
    code.push(["s",order[i],"=j",i].join(""))
    code.push(["j",i,"=0"].join(""))
    code.push(["}else{s",order[i],"=",blockSize].join(""))
    code.push(["j",i,"-=",blockSize,"}"].join(""))
    if(has_index) {
      code.push(["index[",order[i],"]=j",i].join(""))
    }
  }
  for(var i=0; i<nargs; ++i) {
    var indexStr = ["offset"+i]
    for(var j=matched; j<dimension; ++j) {
      indexStr.push(["j",j,"*t",i,"p",order[j]].join(""))
    }
    code.push(["p",i,"=(",indexStr.join("+"),")"].join(""))
  }
  code.push(innerFill(order, proc, body))
  for(var i=matched; i<dimension; ++i) {
    code.push("}")
  }
  return code.join("\n")
}

//Count the number of compatible inner orders
// This is the length of the longest common prefix of the arrays in orders.
// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.
function countMatches(orders) {
  var matched = 0, dimension = orders[0].length
  while(matched < dimension) {
    for(var j=1; j<orders.length; ++j) {
      if(orders[j][matched] !== orders[0][matched]) {
        return matched
      }
    }
    ++matched
  }
  return matched
}

//Processes a block according to the given data types
// Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.
function processBlock(block, proc, dtypes) {
  var code = block.body
  var pre = []
  var post = []
  for(var i=0; i<block.args.length; ++i) {
    var carg = block.args[i]
    if(carg.count <= 0) {
      continue
    }
    var re = new RegExp(carg.name, "g")
    var ptrStr = ""
    var arrNum = proc.arrayArgs.indexOf(i)
    switch(proc.argTypes[i]) {
      case "offset":
        var offArgIndex = proc.offsetArgIndex.indexOf(i)
        var offArg = proc.offsetArgs[offArgIndex]
        arrNum = offArg.array
        ptrStr = "+q" + offArgIndex // Adds offset to the "pointer" in the array
      case "array":
        ptrStr = "p" + arrNum + ptrStr
        var localStr = "l" + i
        var arrStr = "a" + arrNum
        if (proc.arrayBlockIndices[arrNum] === 0) { // Argument to body is just a single value from this array
          if(carg.count === 1) { // Argument/array used only once(?)
            if(dtypes[arrNum] === "generic") {
              if(carg.lvalue) {
                pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
                code = code.replace(re, localStr)
                post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
              } else {
                code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
              }
            } else {
              code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
            }
          } else if(dtypes[arrNum] === "generic") {
            pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
            code = code.replace(re, localStr)
            if(carg.lvalue) {
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            }
          } else {
            pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
            code = code.replace(re, localStr)
            if(carg.lvalue) {
              post.push([arrStr, "[", ptrStr, "]=", localStr].join(""))
            }
          }
        } else { // Argument to body is a "block"
          var reStrArr = [carg.name], ptrStrArr = [ptrStr]
          for(var j=0; j<Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
            reStrArr.push("\\s*\\[([^\\]]+)\\]")
            ptrStrArr.push("$" + (j+1) + "*t" + arrNum + "b" + j) // Matched index times stride
          }
          re = new RegExp(reStrArr.join(""), "g")
          ptrStr = ptrStrArr.join("+")
          if(dtypes[arrNum] === "generic") {
            /*if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }*/
            throw new Error("cwise: Generic arrays not supported in combination with blocks!")
          } else {
            // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
            code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
          }
        }
      break
      case "scalar":
        code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i))
      break
      case "index":
        code = code.replace(re, "index")
      break
      case "shape":
        code = code.replace(re, "shape")
      break
    }
  }
  return [pre.join("\n"), code, post.join("\n")].join("\n").trim()
}

function typeSummary(dtypes) {
  var summary = new Array(dtypes.length)
  var allEqual = true
  for(var i=0; i<dtypes.length; ++i) {
    var t = dtypes[i]
    var digits = t.match(/\d+/)
    if(!digits) {
      digits = ""
    } else {
      digits = digits[0]
    }
    if(t.charAt(0) === 0) {
      summary[i] = "u" + t.charAt(1) + digits
    } else {
      summary[i] = t.charAt(0) + digits
    }
    if(i > 0) {
      allEqual = allEqual && summary[i] === summary[i-1]
    }
  }
  if(allEqual) {
    return summary[0]
  }
  return summary.join("")
}

//Generates a cwise operator
function generateCWiseOp(proc, typesig) {

  //Compute dimension
  // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
  var dimension = (typesig[1].length - Math.abs(proc.arrayBlockIndices[0]))|0
  var orders = new Array(proc.arrayArgs.length)
  var dtypes = new Array(proc.arrayArgs.length)
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    dtypes[i] = typesig[2*i]
    orders[i] = typesig[2*i+1]
  }
  
  //Determine where block and loop indices start and end
  var blockBegin = [], blockEnd = [] // These indices are exposed as blocks
  var loopBegin = [], loopEnd = [] // These indices are iterated over
  var loopOrders = [] // orders restricted to the loop indices
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    if (proc.arrayBlockIndices[i]<0) {
      loopBegin.push(0)
      loopEnd.push(dimension)
      blockBegin.push(dimension)
      blockEnd.push(dimension+proc.arrayBlockIndices[i])
    } else {
      loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative
      loopEnd.push(proc.arrayBlockIndices[i]+dimension)
      blockBegin.push(0)
      blockEnd.push(proc.arrayBlockIndices[i])
    }
    var newOrder = []
    for(var j=0; j<orders[i].length; j++) {
      if (loopBegin[i]<=orders[i][j] && orders[i][j]<loopEnd[i]) {
        newOrder.push(orders[i][j]-loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
      }
    }
    loopOrders.push(newOrder)
  }

  //First create arguments for procedure
  var arglist = ["SS"] // SS is the overall shape over which we iterate
  var code = ["'use strict'"]
  var vars = []
  
  for(var j=0; j<dimension; ++j) {
    vars.push(["s", j, "=SS[", j, "]"].join("")) // The limits for each dimension.
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    arglist.push("a"+i) // Actual data array
    arglist.push("t"+i) // Strides
    arglist.push("p"+i) // Offset in the array at which the data starts (also used for iterating over the data)
    
    for(var j=0; j<dimension; ++j) { // Unpack the strides into vars for looping
      vars.push(["t",i,"p",j,"=t",i,"[",loopBegin[i]+j,"]"].join(""))
    }
    
    for(var j=0; j<Math.abs(proc.arrayBlockIndices[i]); ++j) { // Unpack the strides into vars for block iteration
      vars.push(["t",i,"b",j,"=t",i,"[",blockBegin[i]+j,"]"].join(""))
    }
  }
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    arglist.push("Y" + i)
  }
  if(proc.shapeArgs.length > 0) {
    vars.push("shape=SS.slice(0)") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
  }
  if(proc.indexArgs.length > 0) {
    // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
    var zeros = new Array(dimension)
    for(var i=0; i<dimension; ++i) {
      zeros[i] = "0"
    }
    vars.push(["index=[", zeros.join(","), "]"].join(""))
  }
  for(var i=0; i<proc.offsetArgs.length; ++i) { // Offset arguments used for stencil operations
    var off_arg = proc.offsetArgs[i]
    var init_string = []
    for(var j=0; j<off_arg.offset.length; ++j) {
      if(off_arg.offset[j] === 0) {
        continue
      } else if(off_arg.offset[j] === 1) {
        init_string.push(["t", off_arg.array, "p", j].join(""))      
      } else {
        init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""))
      }
    }
    if(init_string.length === 0) {
      vars.push("q" + i + "=0")
    } else {
      vars.push(["q", i, "=", init_string.join("+")].join(""))
    }
  }

  //Prepare this variables
  var thisVars = uniq([].concat(proc.pre.thisVars)
                      .concat(proc.body.thisVars)
                      .concat(proc.post.thisVars))
  vars = vars.concat(thisVars)
  if (vars.length > 0) {
    code.push("var " + vars.join(","))
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    code.push("p"+i+"|=0")
  }
  
  //Inline prelude
  if(proc.pre.body.length > 3) {
    code.push(processBlock(proc.pre, proc, dtypes))
  }

  //Process body
  var body = processBlock(proc.body, proc, dtypes)
  var matched = countMatches(loopOrders)
  if(matched < dimension) {
    code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
  } else {
    code.push(innerFill(loopOrders[0], proc, body))
  }

  //Inline epilog
  if(proc.post.body.length > 3) {
    code.push(processBlock(proc.post, proc, dtypes))
  }
  
  if(proc.debug) {
    console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------")
  }
  
  var loopName = [(proc.funcName||"unnamed"), "_cwise_loop_", orders[0].join("s"),"m",matched,typeSummary(dtypes)].join("")
  var f = new Function(["function ",loopName,"(", arglist.join(","),"){", code.join("\n"),"} return ", loopName].join(""))
  return f()
}
module.exports = generateCWiseOp


/***/ }),

/***/ "./node_modules/cwise-compiler/lib/thunk.js":
/*!**************************************************!*\
  !*** ./node_modules/cwise-compiler/lib/thunk.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// The function below is called when constructing a cwise function object, and does the following:
// A function object is constructed which accepts as argument a compilation function and returns another function.
// It is this other function that is eventually returned by createThunk, and this function is the one that actually
// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
// The compilation passed to the first function object is used for compiling new functions.
// Once this function object is created, it is called with compile as argument, where the first argument of compile
// is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
// So createThunk roughly works like this:
// function createThunk(proc) {
//   var thunk = function(compileBound) {
//     var CACHED = {}
//     return function(arrays and scalars) {
//       if (dtype and order of arrays in CACHED) {
//         var func = CACHED[dtype and order of arrays]
//       } else {
//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
//       }
//       return func(arrays and scalars)
//     }
//   }
//   return thunk(compile.bind1(proc))
// }

var compile = __webpack_require__(/*! ./compile.js */ "./node_modules/cwise-compiler/lib/compile.js")

function createThunk(proc) {
  var code = ["'use strict'", "var CACHED={}"]
  var vars = []
  var thunkName = proc.funcName + "_cwise_thunk"
  
  //Build thunk
  code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""))
  var typesig = []
  var string_typesig = []
  var proc_args = [["array",proc.arrayArgs[0],".shape.slice(", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
                    Math.max(0,proc.arrayBlockIndices[0]),proc.arrayBlockIndices[0]<0?(","+proc.arrayBlockIndices[0]+")"):")"].join("")]
  var shapeLengthConditions = [], shapeConditions = []
  // Process array arguments
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    var j = proc.arrayArgs[i]
    vars.push(["t", j, "=array", j, ".dtype,",
               "r", j, "=array", j, ".order"].join(""))
    typesig.push("t" + j)
    typesig.push("r" + j)
    string_typesig.push("t"+j)
    string_typesig.push("r"+j+".join()")
    proc_args.push("array" + j + ".data")
    proc_args.push("array" + j + ".stride")
    proc_args.push("array" + j + ".offset|0")
    if (i>0) { // Gather conditions to check for shape equality (ignoring block indices)
      shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0])-Math.abs(proc.arrayBlockIndices[i])))
      shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[i]) + "]")
    }
  }
  // Check for shape equality
  if (proc.arrayArgs.length > 1) {
    code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')")
    code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {")
    code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')")
    code.push("}")
  }
  // Process scalar arguments
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    proc_args.push("scalar" + proc.scalarArgs[i])
  }
  // Check for cached function (and if not present, generate it)
  vars.push(["type=[", string_typesig.join(","), "].join()"].join(""))
  vars.push("proc=CACHED[type]")
  code.push("var " + vars.join(","))
  
  code.push(["if(!proc){",
             "CACHED[type]=proc=compile([", typesig.join(","), "])}",
             "return proc(", proc_args.join(","), ")}"].join(""))

  if(proc.debug) {
    console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------")
  }
  
  //Compile thunk
  var thunk = new Function("compile", code.join("\n"))
  return thunk(compile.bind(undefined, proc))
}

module.exports = createThunk


/***/ }),

/***/ "./node_modules/gl-matrix/esm/common.js":
/*!**********************************************!*\
  !*** ./node_modules/gl-matrix/esm/common.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EPSILON": () => (/* binding */ EPSILON),
/* harmony export */   "ARRAY_TYPE": () => (/* binding */ ARRAY_TYPE),
/* harmony export */   "RANDOM": () => (/* binding */ RANDOM),
/* harmony export */   "setMatrixArrayType": () => (/* binding */ setMatrixArrayType),
/* harmony export */   "toRadian": () => (/* binding */ toRadian),
/* harmony export */   "equals": () => (/* binding */ equals)
/* harmony export */ });
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat4.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "fromValues": () => (/* binding */ fromValues),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "identity": () => (/* binding */ identity),
/* harmony export */   "transpose": () => (/* binding */ transpose),
/* harmony export */   "invert": () => (/* binding */ invert),
/* harmony export */   "adjoint": () => (/* binding */ adjoint),
/* harmony export */   "determinant": () => (/* binding */ determinant),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "translate": () => (/* binding */ translate),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "rotate": () => (/* binding */ rotate),
/* harmony export */   "rotateX": () => (/* binding */ rotateX),
/* harmony export */   "rotateY": () => (/* binding */ rotateY),
/* harmony export */   "rotateZ": () => (/* binding */ rotateZ),
/* harmony export */   "fromTranslation": () => (/* binding */ fromTranslation),
/* harmony export */   "fromScaling": () => (/* binding */ fromScaling),
/* harmony export */   "fromRotation": () => (/* binding */ fromRotation),
/* harmony export */   "fromXRotation": () => (/* binding */ fromXRotation),
/* harmony export */   "fromYRotation": () => (/* binding */ fromYRotation),
/* harmony export */   "fromZRotation": () => (/* binding */ fromZRotation),
/* harmony export */   "fromRotationTranslation": () => (/* binding */ fromRotationTranslation),
/* harmony export */   "fromQuat2": () => (/* binding */ fromQuat2),
/* harmony export */   "getTranslation": () => (/* binding */ getTranslation),
/* harmony export */   "getScaling": () => (/* binding */ getScaling),
/* harmony export */   "getRotation": () => (/* binding */ getRotation),
/* harmony export */   "fromRotationTranslationScale": () => (/* binding */ fromRotationTranslationScale),
/* harmony export */   "fromRotationTranslationScaleOrigin": () => (/* binding */ fromRotationTranslationScaleOrigin),
/* harmony export */   "fromQuat": () => (/* binding */ fromQuat),
/* harmony export */   "frustum": () => (/* binding */ frustum),
/* harmony export */   "perspectiveNO": () => (/* binding */ perspectiveNO),
/* harmony export */   "perspective": () => (/* binding */ perspective),
/* harmony export */   "perspectiveZO": () => (/* binding */ perspectiveZO),
/* harmony export */   "perspectiveFromFieldOfView": () => (/* binding */ perspectiveFromFieldOfView),
/* harmony export */   "orthoNO": () => (/* binding */ orthoNO),
/* harmony export */   "ortho": () => (/* binding */ ortho),
/* harmony export */   "orthoZO": () => (/* binding */ orthoZO),
/* harmony export */   "lookAt": () => (/* binding */ lookAt),
/* harmony export */   "targetTo": () => (/* binding */ targetTo),
/* harmony export */   "str": () => (/* binding */ str),
/* harmony export */   "frob": () => (/* binding */ frob),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "subtract": () => (/* binding */ subtract),
/* harmony export */   "multiplyScalar": () => (/* binding */ multiplyScalar),
/* harmony export */   "multiplyScalarAndAdd": () => (/* binding */ multiplyScalarAndAdd),
/* harmony export */   "exactEquals": () => (/* binding */ exactEquals),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "mul": () => (/* binding */ mul),
/* harmony export */   "sub": () => (/* binding */ sub)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Alias for {@link mat4.perspectiveNO}
 * @function
 */

var perspective = perspectiveNO;
/**
 * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Alias for {@link mat4.orthoNO}
 * @function
 */

var ortho = orthoNO;
/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec3.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "length": () => (/* binding */ length),
/* harmony export */   "fromValues": () => (/* binding */ fromValues),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "subtract": () => (/* binding */ subtract),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "divide": () => (/* binding */ divide),
/* harmony export */   "ceil": () => (/* binding */ ceil),
/* harmony export */   "floor": () => (/* binding */ floor),
/* harmony export */   "min": () => (/* binding */ min),
/* harmony export */   "max": () => (/* binding */ max),
/* harmony export */   "round": () => (/* binding */ round),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "scaleAndAdd": () => (/* binding */ scaleAndAdd),
/* harmony export */   "distance": () => (/* binding */ distance),
/* harmony export */   "squaredDistance": () => (/* binding */ squaredDistance),
/* harmony export */   "squaredLength": () => (/* binding */ squaredLength),
/* harmony export */   "negate": () => (/* binding */ negate),
/* harmony export */   "inverse": () => (/* binding */ inverse),
/* harmony export */   "normalize": () => (/* binding */ normalize),
/* harmony export */   "dot": () => (/* binding */ dot),
/* harmony export */   "cross": () => (/* binding */ cross),
/* harmony export */   "lerp": () => (/* binding */ lerp),
/* harmony export */   "hermite": () => (/* binding */ hermite),
/* harmony export */   "bezier": () => (/* binding */ bezier),
/* harmony export */   "random": () => (/* binding */ random),
/* harmony export */   "transformMat4": () => (/* binding */ transformMat4),
/* harmony export */   "transformMat3": () => (/* binding */ transformMat3),
/* harmony export */   "transformQuat": () => (/* binding */ transformQuat),
/* harmony export */   "rotateX": () => (/* binding */ rotateX),
/* harmony export */   "rotateY": () => (/* binding */ rotateY),
/* harmony export */   "rotateZ": () => (/* binding */ rotateZ),
/* harmony export */   "angle": () => (/* binding */ angle),
/* harmony export */   "zero": () => (/* binding */ zero),
/* harmony export */   "str": () => (/* binding */ str),
/* harmony export */   "exactEquals": () => (/* binding */ exactEquals),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "sub": () => (/* binding */ sub),
/* harmony export */   "mul": () => (/* binding */ mul),
/* harmony export */   "div": () => (/* binding */ div),
/* harmony export */   "dist": () => (/* binding */ dist),
/* harmony export */   "sqrDist": () => (/* binding */ sqrDist),
/* harmony export */   "len": () => (/* binding */ len),
/* harmony export */   "sqrLen": () => (/* binding */ sqrLen),
/* harmony export */   "forEach": () => (/* binding */ forEach)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 * Math.PI;
  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/iota-array/iota.js":
/*!*****************************************!*\
  !*** ./node_modules/iota-array/iota.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


function iota(n) {
  var result = new Array(n)
  for(var i=0; i<n; ++i) {
    result[i] = i
  }
  return result
}

module.exports = iota

/***/ }),

/***/ "./node_modules/is-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/***/ ((module) => {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/***/ ((module) => {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/ktx-parse/dist/ktx-parse.modern.js":
/*!*********************************************************!*\
  !*** ./node_modules/ktx-parse/dist/ktx-parse.modern.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KTX2ChannelETC1S": () => (/* binding */ l),
/* harmony export */   "KTX2ChannelUASTC": () => (/* binding */ f),
/* harmony export */   "KTX2Container": () => (/* binding */ U),
/* harmony export */   "KTX2DescriptorType": () => (/* binding */ i),
/* harmony export */   "KTX2Flags": () => (/* binding */ o),
/* harmony export */   "KTX2Model": () => (/* binding */ s),
/* harmony export */   "KTX2Primaries": () => (/* binding */ a),
/* harmony export */   "KTX2SupercompressionScheme": () => (/* binding */ n),
/* harmony export */   "KTX2Transfer": () => (/* binding */ r),
/* harmony export */   "read": () => (/* binding */ p),
/* harmony export */   "write": () => (/* binding */ y)
/* harmony export */ });
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
const t=new Uint8Array([0]),e=[171,75,84,88,32,50,48,187,13,10,26,10];var n,i,s,a,r,o,l,f;!function(t){t[t.NONE=0]="NONE",t[t.BASISLZ=1]="BASISLZ",t[t.ZSTD=2]="ZSTD",t[t.ZLIB=3]="ZLIB"}(n||(n={})),function(t){t[t.BASICFORMAT=0]="BASICFORMAT"}(i||(i={})),function(t){t[t.UNSPECIFIED=0]="UNSPECIFIED",t[t.ETC1S=163]="ETC1S",t[t.UASTC=166]="UASTC"}(s||(s={})),function(t){t[t.UNSPECIFIED=0]="UNSPECIFIED",t[t.SRGB=1]="SRGB"}(a||(a={})),function(t){t[t.UNSPECIFIED=0]="UNSPECIFIED",t[t.LINEAR=1]="LINEAR",t[t.SRGB=2]="SRGB",t[t.ITU=3]="ITU",t[t.NTSC=4]="NTSC",t[t.SLOG=5]="SLOG",t[t.SLOG2=6]="SLOG2"}(r||(r={})),function(t){t[t.ALPHA_STRAIGHT=0]="ALPHA_STRAIGHT",t[t.ALPHA_PREMULTIPLIED=1]="ALPHA_PREMULTIPLIED"}(o||(o={})),function(t){t[t.RGB=0]="RGB",t[t.RRR=3]="RRR",t[t.GGG=4]="GGG",t[t.AAA=15]="AAA"}(l||(l={})),function(t){t[t.RGB=0]="RGB",t[t.RGBA=3]="RGBA",t[t.RRR=4]="RRR",t[t.RRRG=5]="RRRG"}(f||(f={}));class U{constructor(){this.vkFormat=0,this.typeSize=1,this.pixelWidth=0,this.pixelHeight=0,this.pixelDepth=0,this.layerCount=0,this.faceCount=1,this.supercompressionScheme=n.NONE,this.levels=[],this.dataFormatDescriptor=[{vendorId:0,descriptorType:i.BASICFORMAT,versionNumber:2,descriptorBlockSize:40,colorModel:s.UNSPECIFIED,colorPrimaries:a.SRGB,transferFunction:a.SRGB,flags:o.ALPHA_STRAIGHT,texelBlockDimension:{x:4,y:4,z:1,w:1},bytesPlane:[],samples:[]}],this.keyValue={},this.globalData=null}}class c{constructor(t,e,n,i){this._dataView=new DataView(t.buffer,t.byteOffset+e,n),this._littleEndian=i,this._offset=0}_nextUint8(){const t=this._dataView.getUint8(this._offset);return this._offset+=1,t}_nextUint16(){const t=this._dataView.getUint16(this._offset,this._littleEndian);return this._offset+=2,t}_nextUint32(){const t=this._dataView.getUint32(this._offset,this._littleEndian);return this._offset+=4,t}_nextUint64(){const t=this._dataView.getUint32(this._offset,this._littleEndian)+2**32*this._dataView.getUint32(this._offset+4,this._littleEndian);return this._offset+=8,t}_skip(t){return this._offset+=t,this}_scan(t,e=0){const n=this._offset;let i=0;for(;this._dataView.getUint8(this._offset)!==e&&i<t;)i++,this._offset++;return i<t&&this._offset++,new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+n,i)}}function h(t){return"undefined"!=typeof TextEncoder?(new TextEncoder).encode(t):Buffer.from(t)}function _(t){return"undefined"!=typeof TextDecoder?(new TextDecoder).decode(t):Buffer.from(t).toString("utf8")}function g(t){let e=0;for(const n of t)e+=n.byteLength;const n=new Uint8Array(e);let i=0;for(const e of t)n.set(new Uint8Array(e),i),i+=e.byteLength;return n}function p(t){const n=new Uint8Array(t.buffer,t.byteOffset,e.length);if(n[0]!==e[0]||n[1]!==e[1]||n[2]!==e[2]||n[3]!==e[3]||n[4]!==e[4]||n[5]!==e[5]||n[6]!==e[6]||n[7]!==e[7]||n[8]!==e[8]||n[9]!==e[9]||n[10]!==e[10]||n[11]!==e[11])throw new Error("Missing KTX 2.0 identifier.");const i=new U,s=17*Uint32Array.BYTES_PER_ELEMENT,a=new c(t,e.length,s,!0);i.vkFormat=a._nextUint32(),i.typeSize=a._nextUint32(),i.pixelWidth=a._nextUint32(),i.pixelHeight=a._nextUint32(),i.pixelDepth=a._nextUint32(),i.layerCount=a._nextUint32(),i.faceCount=a._nextUint32();const r=a._nextUint32();i.supercompressionScheme=a._nextUint32();const o=a._nextUint32(),l=a._nextUint32(),f=a._nextUint32(),h=a._nextUint32(),g=a._nextUint64(),p=a._nextUint64(),x=new c(t,e.length+s,3*r*8,!0);for(let e=0;e<r;e++)i.levels.push({levelData:new Uint8Array(t.buffer,t.byteOffset+x._nextUint64(),x._nextUint64()),uncompressedByteLength:x._nextUint64()});const u=new c(t,o,l,!0),y={vendorId:u._skip(4)._nextUint16(),descriptorType:u._nextUint16(),versionNumber:u._nextUint16(),descriptorBlockSize:u._nextUint16(),colorModel:u._nextUint8(),colorPrimaries:u._nextUint8(),transferFunction:u._nextUint8(),flags:u._nextUint8(),texelBlockDimension:{x:u._nextUint8()+1,y:u._nextUint8()+1,z:u._nextUint8()+1,w:u._nextUint8()+1},bytesPlane:[u._nextUint8(),u._nextUint8(),u._nextUint8(),u._nextUint8(),u._nextUint8(),u._nextUint8(),u._nextUint8(),u._nextUint8()],samples:[]},D=(y.descriptorBlockSize/4-6)/4;for(let t=0;t<D;t++)y.samples[t]={bitOffset:u._nextUint16(),bitLength:u._nextUint8(),channelID:u._nextUint8(),samplePosition:[u._nextUint8(),u._nextUint8(),u._nextUint8(),u._nextUint8()],sampleLower:u._nextUint32(),sampleUpper:u._nextUint32()};i.dataFormatDescriptor.length=0,i.dataFormatDescriptor.push(y);const b=new c(t,f,h,!0);for(;b._offset<h;){const t=b._nextUint32(),e=b._scan(t),n=_(e),s=b._scan(t-e.byteLength);i.keyValue[n]=n.match(/^ktx/i)?_(s):s,b._offset%4&&b._skip(4-b._offset%4)}if(p<=0)return i;const d=new c(t,g,p,!0),B=d._nextUint16(),w=d._nextUint16(),A=d._nextUint32(),S=d._nextUint32(),m=d._nextUint32(),L=d._nextUint32(),I=[];for(let t=0;t<r;t++)I.push({imageFlags:d._nextUint32(),rgbSliceByteOffset:d._nextUint32(),rgbSliceByteLength:d._nextUint32(),alphaSliceByteOffset:d._nextUint32(),alphaSliceByteLength:d._nextUint32()});const R=g+d._offset,E=R+A,T=E+S,O=T+m,P=new Uint8Array(t.buffer,t.byteOffset+R,A),C=new Uint8Array(t.buffer,t.byteOffset+E,S),F=new Uint8Array(t.buffer,t.byteOffset+T,m),G=new Uint8Array(t.buffer,t.byteOffset+O,L);return i.globalData={endpointCount:B,selectorCount:w,imageDescs:I,endpointsData:P,selectorsData:C,tablesData:F,extendedData:G},i}function x(){return(x=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t}).apply(this,arguments)}const u={keepWriter:!1};function y(n,s={}){s=x({},u,s);let a=new ArrayBuffer(0);if(n.globalData){const t=new ArrayBuffer(20+5*n.globalData.imageDescs.length*4),e=new DataView(t);e.setUint16(0,n.globalData.endpointCount,!0),e.setUint16(2,n.globalData.selectorCount,!0),e.setUint32(4,n.globalData.endpointsData.byteLength,!0),e.setUint32(8,n.globalData.selectorsData.byteLength,!0),e.setUint32(12,n.globalData.tablesData.byteLength,!0),e.setUint32(16,n.globalData.extendedData.byteLength,!0);for(let t=0;t<n.globalData.imageDescs.length;t++){const i=n.globalData.imageDescs[t];e.setUint32(20+5*t*4+0,i.imageFlags,!0),e.setUint32(20+5*t*4+4,i.rgbSliceByteOffset,!0),e.setUint32(20+5*t*4+8,i.rgbSliceByteLength,!0),e.setUint32(20+5*t*4+12,i.alphaSliceByteOffset,!0),e.setUint32(20+5*t*4+16,i.alphaSliceByteLength,!0)}a=g([t,n.globalData.endpointsData,n.globalData.selectorsData,n.globalData.tablesData,n.globalData.extendedData])}const r=[];let o=n.keyValue;s.keepWriter||(o=x({},n.keyValue,{KTXwriter:"KTX-Parse v0.2.2"}));for(const e in o){const n=o[e],i=h(e),s="string"==typeof n?h(n):n,a=i.byteLength+1+s.byteLength+1,l=a%4?4-a%4:0;r.push(g([new Uint32Array([a]),i,t,s,t,new Uint8Array(l).fill(0)]))}const l=g(r);if(1!==n.dataFormatDescriptor.length||n.dataFormatDescriptor[0].descriptorType!==i.BASICFORMAT)throw new Error("Only BASICFORMAT Data Format Descriptor output supported.");const f=n.dataFormatDescriptor[0],U=new ArrayBuffer(28+16*f.samples.length),c=new DataView(U);c.setUint32(0,U.byteLength,!0),c.setUint16(4,f.vendorId,!0),c.setUint16(6,f.descriptorType,!0),c.setUint16(8,f.versionNumber,!0),c.setUint16(10,f.descriptorBlockSize,!0),c.setUint8(12,f.colorModel),c.setUint8(13,f.colorPrimaries),c.setUint8(14,f.transferFunction),c.setUint8(15,f.flags),c.setUint8(16,f.texelBlockDimension.x-1),c.setUint8(17,f.texelBlockDimension.y-1),c.setUint8(18,f.texelBlockDimension.z-1),c.setUint8(19,f.texelBlockDimension.w-1);for(let t=0;t<8;t++)c.setUint8(20+t,f.bytesPlane[t]);for(let t=0;t<f.samples.length;t++){const e=f.samples[t],n=28+16*t;c.setUint16(n+0,e.bitOffset,!0),c.setUint8(n+2,e.bitLength),c.setUint8(n+3,e.channelID),c.setUint8(n+4,e.samplePosition[0]),c.setUint8(n+5,e.samplePosition[1]),c.setUint8(n+6,e.samplePosition[2]),c.setUint8(n+7,e.samplePosition[3]),c.setUint32(n+8,e.sampleLower,!0),c.setUint32(n+12,e.sampleUpper,!0)}const _=e.length+68+3*n.levels.length*8,p=_+U.byteLength;let y=p+l.byteLength;y%8&&(y+=8-y%8);const D=[],b=new DataView(new ArrayBuffer(3*n.levels.length*8));let d=y+a.byteLength;for(let t=0;t<n.levels.length;t++){const e=n.levels[t];D.push(e.levelData),b.setBigUint64(24*t+0,BigInt(d),!0),b.setBigUint64(24*t+8,BigInt(e.levelData.byteLength),!0),b.setBigUint64(24*t+16,BigInt(e.uncompressedByteLength),!0),d+=e.levelData.byteLength}const B=new ArrayBuffer(68),w=new DataView(B);return w.setUint32(0,n.vkFormat,!0),w.setUint32(4,n.typeSize,!0),w.setUint32(8,n.pixelWidth,!0),w.setUint32(12,n.pixelHeight,!0),w.setUint32(16,n.pixelDepth,!0),w.setUint32(20,n.layerCount,!0),w.setUint32(24,n.faceCount,!0),w.setUint32(28,n.levels.length,!0),w.setUint32(32,n.supercompressionScheme,!0),w.setUint32(36,_,!0),w.setUint32(40,U.byteLength,!0),w.setUint32(44,p,!0),w.setUint32(48,l.byteLength,!0),w.setBigUint64(52,BigInt(y),!0),w.setBigUint64(60,BigInt(a.byteLength),!0),new Uint8Array(g([new Uint8Array(e).buffer,B,b.buffer,U,l,new ArrayBuffer(y-(p+l.byteLength)),a,...D]))}
//# sourceMappingURL=ktx-parse.modern.js.map


/***/ }),

/***/ "./node_modules/ndarray-lanczos/dist/ndarray-lanczos.modern.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ndarray-lanczos/dist/ndarray-lanczos.modern.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "lanczos2": () => (/* binding */ c),
/* harmony export */   "lanczos3": () => (/* binding */ h)
/* harmony export */ });
/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ndarray */ "./node_modules/ndarray/ndarray.js");
/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ndarray__WEBPACK_IMPORTED_MODULE_0__);
const e=(t,e)=>{if(t<=-e||t>=e)return 0;const n=t*Math.PI;return Math.sin(n)/n*Math.sin(n/e)/(n/e)},n=t=>Math.round(16383*t),r=(t,r,o,a,s)=>{const l=s?2:3,h=1/o,c=Math.min(1,o),f=l/c,i=Math.floor(2*(f+1)),A=new Int16Array((i+2)*r);let M=0;for(let o=0;o<r;o++){const s=(o+.5)*h+a,i=Math.max(0,Math.floor(s-f)),u=Math.min(t-1,Math.ceil(s+f)),p=u-i+1,C=new Float32Array(p),L=new Int16Array(p);let N=0,O=0;for(let t=i;t<=u;t++){const n=e((t+.5-s)*c,l);N+=n,C[O]=n,O++}let S=0;for(let t=0;t<C.length;t++){const e=C[t]/N;S+=e,L[t]=n(e)}L[r>>1]+=n(1-S);let Z=0;for(;Z<L.length&&0===L[Z];)Z++;let _=L.length-1;for(;_>0&&0===L[_];)_--;const g=_-Z+1;A[M++]=i+Z,A[M++]=g,A.set(L.subarray(Z,_+1),M),M+=g}return A},o=t=>t<0?0:t>255?255:t,a=(t,e,n)=>{const[r,a]=t.shape,[s]=e.shape;for(let r=0;r<a;r++){const a=r;let l=0;for(let h=0;h<s;h++){let s=n[l++],c=0,f=0,i=0,A=0;for(let e=n[l++];e>0;e--){const e=n[l++];c+=e*t.get(s,r,0),f+=e*t.get(s,r,1),i+=e*t.get(s,r,2),A+=e*t.get(s,r,3),s++}e.set(h,a,0,o(c+8192>>14)),e.set(h,a,1,o(f+8192>>14)),e.set(h,a,2,o(i+8192>>14)),e.set(h,a,3,o(A+8192>>14))}}};var s;function l(e,n,o){const[l,h]=e.shape,[c,f]=n.shape,i=f/h,A=r(l,c,c/l,0,o===s.LANCZOS_2),M=r(h,f,i,0,o===s.LANCZOS_2),u=ndarray__WEBPACK_IMPORTED_MODULE_0___default()(new Uint8Array(c*h*4),[h,c,4]),p=u.transpose(1,0),C=n.transpose(1,0);a(e,p,A),a(u,C,M)}function h(t,e){l(t,e,s.LANCZOS_3)}function c(t,e){l(t,e,s.LANCZOS_2)}!function(t){t[t.LANCZOS_3=3]="LANCZOS_3",t[t.LANCZOS_2=2]="LANCZOS_2"}(s||(s={}));
//# sourceMappingURL=ndarray-lanczos.modern.js.map


/***/ }),

/***/ "./node_modules/ndarray-ops/ndarray-ops.js":
/*!*************************************************!*\
  !*** ./node_modules/ndarray-ops/ndarray-ops.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var compile = __webpack_require__(/*! cwise-compiler */ "./node_modules/cwise-compiler/compiler.js")

var EmptyProc = {
  body: "",
  args: [],
  thisVars: [],
  localVars: []
}

function fixup(x) {
  if(!x) {
    return EmptyProc
  }
  for(var i=0; i<x.args.length; ++i) {
    var a = x.args[i]
    if(i === 0) {
      x.args[i] = {name: a, lvalue:true, rvalue: !!x.rvalue, count:x.count||1 }
    } else {
      x.args[i] = {name: a, lvalue:false, rvalue:true, count: 1}
    }
  }
  if(!x.thisVars) {
    x.thisVars = []
  }
  if(!x.localVars) {
    x.localVars = []
  }
  return x
}

function pcompile(user_args) {
  return compile({
    args:     user_args.args,
    pre:      fixup(user_args.pre),
    body:     fixup(user_args.body),
    post:     fixup(user_args.proc),
    funcName: user_args.funcName
  })
}

function makeOp(user_args) {
  var args = []
  for(var i=0; i<user_args.args.length; ++i) {
    args.push("a"+i)
  }
  var wrapper = new Function("P", [
    "return function ", user_args.funcName, "_ndarrayops(", args.join(","), ") {P(", args.join(","), ");return a0}"
  ].join(""))
  return wrapper(pcompile(user_args))
}

var assign_ops = {
  add:  "+",
  sub:  "-",
  mul:  "*",
  div:  "/",
  mod:  "%",
  band: "&",
  bor:  "|",
  bxor: "^",
  lshift: "<<",
  rshift: ">>",
  rrshift: ">>>"
}
;(function(){
  for(var id in assign_ops) {
    var op = assign_ops[id]
    exports[id] = makeOp({
      args: ["array","array","array"],
      body: {args:["a","b","c"],
             body: "a=b"+op+"c"},
      funcName: id
    })
    exports[id+"eq"] = makeOp({
      args: ["array","array"],
      body: {args:["a","b"],
             body:"a"+op+"=b"},
      rvalue: true,
      funcName: id+"eq"
    })
    exports[id+"s"] = makeOp({
      args: ["array", "array", "scalar"],
      body: {args:["a","b","s"],
             body:"a=b"+op+"s"},
      funcName: id+"s"
    })
    exports[id+"seq"] = makeOp({
      args: ["array","scalar"],
      body: {args:["a","s"],
             body:"a"+op+"=s"},
      rvalue: true,
      funcName: id+"seq"
    })
  }
})();

var unary_ops = {
  not: "!",
  bnot: "~",
  neg: "-",
  recip: "1.0/"
}
;(function(){
  for(var id in unary_ops) {
    var op = unary_ops[id]
    exports[id] = makeOp({
      args: ["array", "array"],
      body: {args:["a","b"],
             body:"a="+op+"b"},
      funcName: id
    })
    exports[id+"eq"] = makeOp({
      args: ["array"],
      body: {args:["a"],
             body:"a="+op+"a"},
      rvalue: true,
      count: 2,
      funcName: id+"eq"
    })
  }
})();

var binary_ops = {
  and: "&&",
  or: "||",
  eq: "===",
  neq: "!==",
  lt: "<",
  gt: ">",
  leq: "<=",
  geq: ">="
}
;(function() {
  for(var id in binary_ops) {
    var op = binary_ops[id]
    exports[id] = makeOp({
      args: ["array","array","array"],
      body: {args:["a", "b", "c"],
             body:"a=b"+op+"c"},
      funcName: id
    })
    exports[id+"s"] = makeOp({
      args: ["array","array","scalar"],
      body: {args:["a", "b", "s"],
             body:"a=b"+op+"s"},
      funcName: id+"s"
    })
    exports[id+"eq"] = makeOp({
      args: ["array", "array"],
      body: {args:["a", "b"],
             body:"a=a"+op+"b"},
      rvalue:true,
      count:2,
      funcName: id+"eq"
    })
    exports[id+"seq"] = makeOp({
      args: ["array", "scalar"],
      body: {args:["a","s"],
             body:"a=a"+op+"s"},
      rvalue:true,
      count:2,
      funcName: id+"seq"
    })
  }
})();

var math_unary = [
  "abs",
  "acos",
  "asin",
  "atan",
  "ceil",
  "cos",
  "exp",
  "floor",
  "log",
  "round",
  "sin",
  "sqrt",
  "tan"
]
;(function() {
  for(var i=0; i<math_unary.length; ++i) {
    var f = math_unary[i]
    exports[f] = makeOp({
                    args: ["array", "array"],
                    pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                    body: {args:["a","b"], body:"a=this_f(b)", thisVars:["this_f"]},
                    funcName: f
                  })
    exports[f+"eq"] = makeOp({
                      args: ["array"],
                      pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                      body: {args: ["a"], body:"a=this_f(a)", thisVars:["this_f"]},
                      rvalue: true,
                      count: 2,
                      funcName: f+"eq"
                    })
  }
})();

var math_comm = [
  "max",
  "min",
  "atan2",
  "pow"
]
;(function(){
  for(var i=0; i<math_comm.length; ++i) {
    var f= math_comm[i]
    exports[f] = makeOp({
                  args:["array", "array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                  funcName: f
                })
    exports[f+"s"] = makeOp({
                  args:["array", "array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                  funcName: f+"s"
                  })
    exports[f+"eq"] = makeOp({ args:["array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                  rvalue: true,
                  count: 2,
                  funcName: f+"eq"
                  })
    exports[f+"seq"] = makeOp({ args:["array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                  rvalue:true,
                  count:2,
                  funcName: f+"seq"
                  })
  }
})();

var math_noncomm = [
  "atan2",
  "pow"
]
;(function(){
  for(var i=0; i<math_noncomm.length; ++i) {
    var f= math_noncomm[i]
    exports[f+"op"] = makeOp({
                  args:["array", "array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                  funcName: f+"op"
                })
    exports[f+"ops"] = makeOp({
                  args:["array", "array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                  funcName: f+"ops"
                  })
    exports[f+"opeq"] = makeOp({ args:["array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                  rvalue: true,
                  count: 2,
                  funcName: f+"opeq"
                  })
    exports[f+"opseq"] = makeOp({ args:["array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                  rvalue:true,
                  count:2,
                  funcName: f+"opseq"
                  })
  }
})();

exports.any = compile({
  args:["array"],
  pre: EmptyProc,
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "if(a){return true}", localVars: [], thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return false"},
  funcName: "any"
})

exports.all = compile({
  args:["array"],
  pre: EmptyProc,
  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1}], body: "if(!x){return false}", localVars: [], thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return true"},
  funcName: "all"
})

exports.sum = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s+=a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "sum"
})

exports.prod = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=1"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s*=a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "prod"
})

exports.norm2squared = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norm2squared"
})
  
exports.norm2 = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return Math.sqrt(this_s)"},
  funcName: "norm2"
})
  

exports.norminf = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:4}], body:"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norminf"
})

exports.norm1 = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:3}], body: "this_s+=a<0?-a:a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norm1"
})

exports.sup = compile({
  args: [ "array" ],
  pre:
   { body: "this_h=-Infinity",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] },
  body:
   { body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
     thisVars: [ "this_h" ],
     localVars: [] },
  post:
   { body: "return this_h",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] }
 })

exports.inf = compile({
  args: [ "array" ],
  pre:
   { body: "this_h=Infinity",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] },
  body:
   { body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
     thisVars: [ "this_h" ],
     localVars: [] },
  post:
   { body: "return this_h",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] }
 })

exports.argmin = compile({
  args:["index","array","shape"],
  pre:{
    body:"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args:[
      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
      ],
    thisVars:["this_i","this_v"],
    localVars:[]},
  body:{
    body:"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args:[
      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
    thisVars:["this_i","this_v"],
    localVars:["_inline_1_k"]},
  post:{
    body:"{return this_i}",
    args:[],
    thisVars:["this_i"],
    localVars:[]}
})

exports.argmax = compile({
  args:["index","array","shape"],
  pre:{
    body:"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args:[
      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
      ],
    thisVars:["this_i","this_v"],
    localVars:[]},
  body:{
    body:"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args:[
      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
    thisVars:["this_i","this_v"],
    localVars:["_inline_1_k"]},
  post:{
    body:"{return this_i}",
    args:[],
    thisVars:["this_i"],
    localVars:[]}
})  

exports.random = makeOp({
  args: ["array"],
  pre: {args:[], body:"this_f=Math.random", thisVars:["this_f"]},
  body: {args: ["a"], body:"a=this_f()", thisVars:["this_f"]},
  funcName: "random"
})

exports.assign = makeOp({
  args:["array", "array"],
  body: {args:["a", "b"], body:"a=b"},
  funcName: "assign" })

exports.assigns = makeOp({
  args:["array", "scalar"],
  body: {args:["a", "b"], body:"a=b"},
  funcName: "assigns" })


exports.equals = compile({
  args:["array", "array"],
  pre: EmptyProc,
  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1},
               {name:"y", lvalue:false, rvalue:true, count:1}], 
        body: "if(x!==y){return false}", 
        localVars: [], 
        thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return true"},
  funcName: "equals"
})




/***/ }),

/***/ "./node_modules/ndarray-pixels/dist/ndarray-pixels-browser.modern.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ndarray-pixels/dist/ndarray-pixels-browser.modern.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getPixels": () => (/* binding */ i),
/* harmony export */   "savePixels": () => (/* binding */ o)
/* harmony export */ });
/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ndarray */ "./node_modules/ndarray/ndarray.js");
/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ndarray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ndarray_ops__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ndarray-ops */ "./node_modules/ndarray-ops/ndarray-ops.js");
/* harmony import */ var ndarray_ops__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ndarray_ops__WEBPACK_IMPORTED_MODULE_1__);
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
function a(e,t,a={}){const i=document.createElement("canvas");i.width=e.shape[0],i.height=e.shape[1];const o=i.getContext("2d"),h=o.getImageData(0,0,i.width,i.height);try{n(e,h.data)}catch(e){return s.from(Promise.reject(e))}o.putImageData(h,0,0);const p=a.quality?a.quality/100:void 0;switch(t){case"canvas":return i;case"jpg":case"jpeg":return r(i,"image/jpeg",p);case"png":return r(i,"image/png");default:throw new Error("[ndarray-pixels] Unsupported file type: "+t)}}function r(e,t,a){const r=new Promise((r,n)=>{e.toBlob(async e=>{e?r(new Uint8Array(await e.arrayBuffer())):n(new Error("[ndarray-pixels] Failed to canvas.toBlob()."))},t,a)});return s.from(r)}function n(a,r,s=-1){if(4===a.shape.length)return n(a.pick(s),r,0);if(3===a.shape.length)if(3===a.shape[2])ndarray_ops__WEBPACK_IMPORTED_MODULE_1___default().assign(ndarray__WEBPACK_IMPORTED_MODULE_0___default()(r,[a.shape[0],a.shape[1],3],[4,4*a.shape[0],1]),a),ndarray_ops__WEBPACK_IMPORTED_MODULE_1___default().assigns(ndarray__WEBPACK_IMPORTED_MODULE_0___default()(r,[a.shape[0]*a.shape[1]],[4],3),255);else if(4===a.shape[2])ndarray_ops__WEBPACK_IMPORTED_MODULE_1___default().assign(ndarray__WEBPACK_IMPORTED_MODULE_0___default()(r,[a.shape[0],a.shape[1],4],[4,4*a.shape[0],1]),a);else{if(1!==a.shape[2])throw new Error("[ndarray-pixels] Incompatible array shape.");ndarray_ops__WEBPACK_IMPORTED_MODULE_1___default().assign(ndarray__WEBPACK_IMPORTED_MODULE_0___default()(r,[a.shape[0],a.shape[1],3],[4,4*a.shape[0],1]),ndarray__WEBPACK_IMPORTED_MODULE_0___default()(a.data,[a.shape[0],a.shape[1],3],[a.stride[0],a.stride[1],0],a.offset)),ndarray_ops__WEBPACK_IMPORTED_MODULE_1___default().assigns(ndarray__WEBPACK_IMPORTED_MODULE_0___default()(r,[a.shape[0]*a.shape[1]],[4],3),255)}else{if(2!==a.shape.length)throw new Error("[ndarray-pixels] Incompatible array shape.");ndarray_ops__WEBPACK_IMPORTED_MODULE_1___default().assign(ndarray__WEBPACK_IMPORTED_MODULE_0___default()(r,[a.shape[0],a.shape[1],3],[4,4*a.shape[0],1]),ndarray__WEBPACK_IMPORTED_MODULE_0___default()(a.data,[a.shape[0],a.shape[1],3],[a.stride[0],a.stride[1],0],a.offset)),ndarray_ops__WEBPACK_IMPORTED_MODULE_1___default().assigns(ndarray__WEBPACK_IMPORTED_MODULE_0___default()(r,[a.shape[0]*a.shape[1]],[4],3),255)}return r}class s{constructor(e){this._promise=void 0,this._promise=e}on(e,t){return"data"===e?this._promise.then(t):"error"===e?this._promise.catch(t):"end"===e&&this._promise.finally(t),this}static from(e){return new s(e)}}async function i(t,a){return t instanceof Uint8Array&&"undefined"!=typeof Buffer&&(t=Buffer.from(t)),new Promise((r,n)=>{!function(t,a,r){if(r=r||a,t instanceof Uint8Array){if("string"!=typeof a)throw new Error("[ndarray-pixels] Type must be given for Uint8Array image data");const e=new Blob([t],{type:a});t=URL.createObjectURL(e)}const n=new Image;n.crossOrigin="anonymous",n.onload=function(){URL.revokeObjectURL(t);const a=document.createElement("canvas");a.width=n.width,a.height=n.height;const s=a.getContext("2d");s.drawImage(n,0,0);const i=s.getImageData(0,0,n.width,n.height);r(null,ndarray__WEBPACK_IMPORTED_MODULE_0___default()(new Uint8Array(i.data),[n.width,n.height,4],[4,4*n.width,1],0))},n.onerror=e=>{URL.revokeObjectURL(t),r(e)},n.src=t}(t,a,(e,t)=>{t&&!e?r(t):n(e)})})}async function o(e,t){return new Promise((r,n)=>{const s=[],i=t.replace("image/","");a(e,i).on("data",e=>s.push(e)).on("end",()=>r(function(e){let t=0;for(const a of e)t+=a.byteLength;const a=new Uint8Array(t);let r=0;for(const t of e)a.set(t,r),r+=t.byteLength;return a}(s))).on("error",e=>n(e))})}
//# sourceMappingURL=ndarray-pixels-browser.modern.js.map


/***/ }),

/***/ "./node_modules/ndarray/ndarray.js":
/*!*****************************************!*\
  !*** ./node_modules/ndarray/ndarray.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var iota = __webpack_require__(/*! iota-array */ "./node_modules/iota-array/iota.js")
var isBuffer = __webpack_require__(/*! is-buffer */ "./node_modules/is-buffer/index.js")

var hasTypedArrays  = ((typeof Float64Array) !== "undefined")

function compare1st(a, b) {
  return a[0] - b[0]
}

function order() {
  var stride = this.stride
  var terms = new Array(stride.length)
  var i
  for(i=0; i<terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i]
  }
  terms.sort(compare1st)
  var result = new Array(terms.length)
  for(i=0; i<result.length; ++i) {
    result[i] = terms[i][1]
  }
  return result
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("")
  if(dimension < 0) {
    className = "View_Nil" + dtype
  }
  var useGetters = (dtype === "generic")

  if(dimension === -1) {
    //Special case for trivial arrays
    var code =
      "function "+className+"(a){this.data=a;};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new "+className+"(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_"+className+"(a){return new "+className+"(a);}"
    var procedure = new Function(code)
    return procedure()
  } else if(dimension === 0) {
    //Special case for 0d arrays
    var code =
      "function "+className+"(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function "+className+"_copy() {\
return new "+className+"(this.data,this.offset)\
};\
proto.pick=function "+className+"_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function "+className+"_get(){\
return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
"};\
proto.set=function "+className+"_set(v){\
return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
};\
return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}"
    var procedure = new Function("TrivialArray", code)
    return procedure(CACHED_CONSTRUCTORS[dtype][0])
  }

  var code = ["'use strict'"]

  //Create constructor for view
  var indices = iota(dimension)
  var args = indices.map(function(i) { return "i"+i })
  var index_str = "this.offset+" + indices.map(function(i) {
        return "this.stride[" + i + "]*i" + i
      }).join("+")
  var shapeArg = indices.map(function(i) {
      return "b"+i
    }).join(",")
  var strideArg = indices.map(function(i) {
      return "c"+i
    }).join(",")
  code.push(
    "function "+className+"(a," + shapeArg + "," + strideArg + ",d){this.data=a",
      "this.shape=[" + shapeArg + "]",
      "this.stride=[" + strideArg + "]",
      "this.offset=d|0}",
    "var proto="+className+".prototype",
    "proto.dtype='"+dtype+"'",
    "proto.dimension="+dimension)

  //view.size:
  code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
return "+indices.map(function(i) { return "this.shape["+i+"]" }).join("*"),
"}})")

  //view.order:
  if(dimension === 1) {
    code.push("proto.order=[0]")
  } else {
    code.push("Object.defineProperty(proto,'order',{get:")
    if(dimension < 4) {
      code.push("function "+className+"_order(){")
      if(dimension === 2) {
        code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})")
      } else if(dimension === 3) {
        code.push(
"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})")
      }
    } else {
      code.push("ORDER})")
    }
  }

  //view.set(i0, ..., v):
  code.push(
"proto.set=function "+className+"_set("+args.join(",")+",v){")
  if(useGetters) {
    code.push("return this.data.set("+index_str+",v)}")
  } else {
    code.push("return this.data["+index_str+"]=v}")
  }

  //view.get(i0, ...):
  code.push("proto.get=function "+className+"_get("+args.join(",")+"){")
  if(useGetters) {
    code.push("return this.data.get("+index_str+")}")
  } else {
    code.push("return this.data["+index_str+"]}")
  }

  //view.index:
  code.push(
    "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}")

  //view.hi():
  code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
    indices.map(function(i) {
      return ["(typeof i",i,"!=='number'||i",i,"<0)?this.shape[", i, "]:i", i,"|0"].join("")
    }).join(",")+","+
    indices.map(function(i) {
      return "this.stride["+i + "]"
    }).join(",")+",this.offset)}")

  //view.lo():
  var a_vars = indices.map(function(i) { return "a"+i+"=this.shape["+i+"]" })
  var c_vars = indices.map(function(i) { return "c"+i+"=this.stride["+i+"]" })
  code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","))
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'&&i"+i+">=0){\
d=i"+i+"|0;\
b+=c"+i+"*d;\
a"+i+"-=d}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "c"+i
    }).join(",")+",b)}")

  //view.step():
  code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
    indices.map(function(i) {
      return "a"+i+"=this.shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "b"+i+"=this.stride["+i+"]"
    }).join(",")+",c=this.offset,d=0,ceil=Math.ceil")
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'){\
d=i"+i+"|0;\
if(d<0){\
c+=b"+i+"*(a"+i+"-1);\
a"+i+"=ceil(-a"+i+"/d)\
}else{\
a"+i+"=ceil(a"+i+"/d)\
}\
b"+i+"*=d\
}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a" + i
    }).join(",")+","+
    indices.map(function(i) {
      return "b" + i
    }).join(",")+",c)}")

  //view.transpose():
  var tShape = new Array(dimension)
  var tStride = new Array(dimension)
  for(var i=0; i<dimension; ++i) {
    tShape[i] = "a[i"+i+"]"
    tStride[i] = "b[i"+i+"]"
  }
  code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
    args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
    "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}")

  //view.pick():
  code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset")
  for(var i=0; i<dimension; ++i) {
    code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this.stride["+i+"]*i"+i+")|0}else{a.push(this.shape["+i+"]);b.push(this.stride["+i+"])}")
  }
  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}")

  //Add return statement
  code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
    indices.map(function(i) {
      return "shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "stride["+i+"]"
    }).join(",")+",offset)}")

  //Compile procedure
  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"))
  return procedure(CACHED_CONSTRUCTORS[dtype], order)
}

function arrayDType(data) {
  if(isBuffer(data)) {
    return "buffer"
  }
  if(hasTypedArrays) {
    switch(Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64"
      case "[object Float32Array]":
        return "float32"
      case "[object Int8Array]":
        return "int8"
      case "[object Int16Array]":
        return "int16"
      case "[object Int32Array]":
        return "int32"
      case "[object Uint8Array]":
        return "uint8"
      case "[object Uint16Array]":
        return "uint16"
      case "[object Uint32Array]":
        return "uint32"
      case "[object Uint8ClampedArray]":
        return "uint8_clamped"
      case "[object BigInt64Array]":
        return "bigint64"
      case "[object BigUint64Array]":
        return "biguint64"
    }
  }
  if(Array.isArray(data)) {
    return "array"
  }
  return "generic"
}

var CACHED_CONSTRUCTORS = {
  "float32":[],
  "float64":[],
  "int8":[],
  "int16":[],
  "int32":[],
  "uint8":[],
  "uint16":[],
  "uint32":[],
  "array":[],
  "uint8_clamped":[],
  "bigint64": [],
  "biguint64": [],
  "buffer":[],
  "generic":[]
}

;(function() {
  for(var id in CACHED_CONSTRUCTORS) {
    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))
  }
});

function wrappedNDArrayCtor(data, shape, stride, offset) {
  if(data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0]
    return ctor([])
  } else if(typeof data === "number") {
    data = [data]
  }
  if(shape === undefined) {
    shape = [ data.length ]
  }
  var d = shape.length
  if(stride === undefined) {
    stride = new Array(d)
    for(var i=d-1, sz=1; i>=0; --i) {
      stride[i] = sz
      sz *= shape[i]
    }
  }
  if(offset === undefined) {
    offset = 0
    for(var i=0; i<d; ++i) {
      if(stride[i] < 0) {
        offset -= (shape[i]-1)*stride[i]
      }
    }
  }
  var dtype = arrayDType(data)
  var ctor_list = CACHED_CONSTRUCTORS[dtype]
  while(ctor_list.length <= d+1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))
  }
  var ctor = ctor_list[d+1]
  return ctor(data, shape, stride, offset)
}

module.exports = wrappedNDArrayCtor


/***/ }),

/***/ "./node_modules/property-graph/dist/property-graph.modern.js":
/*!*******************************************************************!*\
  !*** ./node_modules/property-graph/dist/property-graph.modern.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$attributes": () => (/* binding */ d),
/* harmony export */   "$immutableKeys": () => (/* binding */ a),
/* harmony export */   "EventDispatcher": () => (/* binding */ t),
/* harmony export */   "Graph": () => (/* binding */ s),
/* harmony export */   "GraphEdge": () => (/* binding */ e),
/* harmony export */   "GraphNode": () => (/* binding */ o),
/* harmony export */   "isRef": () => (/* binding */ r),
/* harmony export */   "isRefList": () => (/* binding */ n),
/* harmony export */   "isRefMap": () => (/* binding */ h)
/* harmony export */ });
class t{constructor(){this._listeners={}}addEventListener(t,e){const s=this._listeners;return void 0===s[t]&&(s[t]=[]),-1===s[t].indexOf(e)&&s[t].push(e),this}removeEventListener(t,e){if(void 0===this._listeners)return this;const s=this._listeners[t];if(void 0!==s){const t=s.indexOf(e);-1!==t&&s.splice(t,1)}return this}dispatchEvent(t){if(void 0===this._listeners)return this;const e=this._listeners[t.type];if(void 0!==e){const s=e.slice(0);for(let e=0,i=s.length;e<i;e++)s[e].call(this,t)}return this}dispose(){for(const t in this._listeners)delete this._listeners[t]}}class e extends t{constructor(t,e,s,i={}){if(super(),this._name=void 0,this._parent=void 0,this._child=void 0,this._attributes=void 0,this._disposed=!1,this._name=t,this._parent=e,this._child=s,this._attributes=i,!e.isOnGraph(s))throw new Error("Cannot connect disconnected graphs.")}getName(){return this._name}getParent(){return this._parent}getChild(){return this._child}setChild(t){return this._child=t,this}getAttributes(){return this._attributes}dispose(){this._disposed||(this._disposed=!0,this.dispatchEvent({type:"dispose",target:this}),super.dispose())}isDisposed(){return this._disposed}}class s extends t{constructor(...t){super(...t),this._emptySet=new Set,this._edges=new Set,this._parentEdges=new Map,this._childEdges=new Map}listEdges(){return Array.from(this._edges)}listParentEdges(t){return Array.from(this._childEdges.get(t)||this._emptySet)}listParents(t){return this.listParentEdges(t).map(t=>t.getParent())}listChildEdges(t){return Array.from(this._parentEdges.get(t)||this._emptySet)}listChildren(t){return this.listChildEdges(t).map(t=>t.getChild())}disconnectParents(t,e){let s=this.listParentEdges(t);return e&&(s=s.filter(t=>e(t.getParent()))),s.forEach(t=>t.dispose()),this}createEdge(t,s,i,r){return this._registerEdge(new e(t,s,i,r))}_registerEdge(t){this._edges.add(t);const e=t.getParent();this._parentEdges.has(e)||this._parentEdges.set(e,new Set),this._parentEdges.get(e).add(t);const s=t.getChild();return this._childEdges.has(s)||this._childEdges.set(s,new Set),this._childEdges.get(s).add(t),t.addEventListener("dispose",()=>this._removeEdge(t)),t}_removeEdge(t){return this._edges.delete(t),this._parentEdges.get(t.getParent()).delete(t),this._childEdges.get(t.getChild()).delete(t),this}}function i(){return i=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var s=arguments[e];for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&(t[i]=s[i])}return t},i.apply(this,arguments)}function r(t){return t instanceof e}function n(t){return Array.isArray(t)&&t[0]instanceof e}function h(t){return!!(t&&"object"==typeof t&&Object.values(t)[0]instanceof e)}const d=Symbol("attributes"),a=Symbol("immutableKeys");class o extends t{constructor(t){super(),this._disposed=!1,this.graph=void 0,this[d]=void 0,this[a]=void 0,this.graph=t,this[a]=new Set,this[d]=this._createAttributes()}getDefaults(){return{}}_createAttributes(){const t=this.getDefaults(),e={};for(const s in t){const i=t[s];if(i instanceof o){const t=this.graph.createEdge(s,this,i);t.addEventListener("dispose",()=>i.dispose()),this[a].add(s),e[s]=t}else e[s]=i}return e}isOnGraph(t){return this.graph===t.graph}isDisposed(){return this._disposed}dispose(){this._disposed||(this.graph.listChildEdges(this).forEach(t=>t.dispose()),this.graph.disconnectParents(this),this._disposed=!0,this.dispatchEvent({type:"dispose"}))}detach(){return this.graph.disconnectParents(this),this}swap(t,e){for(const s in this[d]){const i=this[d][s];if(r(i)){const r=i;r.getChild()===t&&this.setRef(s,e,r.getAttributes())}else if(n(i)){const r=i.find(e=>e.getChild()===t);if(r){const i=r.getAttributes();this.removeRef(s,t).addRef(s,e,i)}}else if(h(i)){const r=i;for(const i in r){const n=r[i];n.getChild()===t&&this.setRefMap(s,i,e,n.getAttributes())}}}return this}get(t){return this[d][t]}set(t,e){return this[d][t]=e,this.dispatchEvent({type:"change",attribute:t})}getRef(t){const e=this[d][t];return e?e.getChild():null}setRef(t,e,s){if(this[a].has(t))throw new Error(`Cannot overwrite immutable attribute, "${t}".`);const i=this[d][t];if(i&&i.dispose(),!e)return this;const r=this.graph.createEdge(t,this,e,s);return r.addEventListener("dispose",()=>{delete this[d][t],this.dispatchEvent({type:"change",attribute:t})}),this[d][t]=r,this.dispatchEvent({type:"change",attribute:t})}listRefs(t){return this[d][t].map(t=>t.getChild())}addRef(t,e,s){const i=this.graph.createEdge(t,this,e,s),r=this[d][t];return r.push(i),i.addEventListener("dispose",()=>{const e=r.filter(t=>t!==i);r.length=0;for(const t of e)r.push(t);this.dispatchEvent({type:"change",attribute:t})}),this.dispatchEvent({type:"change",attribute:t})}removeRef(t,e){return this[d][t].filter(t=>t.getChild()===e).forEach(t=>t.dispose()),this}listRefMapKeys(t){return Object.keys(this[d][t])}listRefMapValues(t){return Object.values(this[d][t]).map(t=>t.getChild())}getRefMap(t,e){const s=this[d][t];return s[e]?s[e].getChild():null}setRefMap(t,e,s,r){const n=this[d][t],h=n[e];if(h&&h.dispose(),!s)return this;r=Object.assign(r||{},{key:e});const a=this.graph.createEdge(t,this,s,i({},r,{key:e}));return a.addEventListener("dispose",()=>{delete n[e],this.dispatchEvent({type:"change",attribute:t,key:e})}),n[e]=a,this.dispatchEvent({type:"change",attribute:t,key:e})}dispatchEvent(t){return super.dispatchEvent(i({},t,{target:this})),this.graph.dispatchEvent(i({},t,{target:this,type:`node:${t.type}`})),this}}
//# sourceMappingURL=property-graph.modern.js.map


/***/ }),

/***/ "./node_modules/uniq/uniq.js":
/*!***********************************!*\
  !*** ./node_modules/uniq/uniq.js ***!
  \***********************************/
/***/ ((module) => {

"use strict";


function unique_pred(list, compare) {
  var ptr = 1
    , len = list.length
    , a=list[0], b=list[0]
  for(var i=1; i<len; ++i) {
    b = a
    a = list[i]
    if(compare(a, b)) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique_eq(list) {
  var ptr = 1
    , len = list.length
    , a=list[0], b = list[0]
  for(var i=1; i<len; ++i, b=a) {
    b = a
    a = list[i]
    if(a !== b) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique(list, compare, sorted) {
  if(list.length === 0) {
    return list
  }
  if(compare) {
    if(!sorted) {
      list.sort(compare)
    }
    return unique_pred(list, compare)
  }
  if(!sorted) {
    list.sort()
  }
  return unique_eq(list)
}

module.exports = unique


/***/ }),

/***/ "?b42e":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?bf19":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ })

}]);